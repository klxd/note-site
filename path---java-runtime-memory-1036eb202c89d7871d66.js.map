{"version":3,"sources":["webpack:///path---java-runtime-memory-1036eb202c89d7871d66.js","webpack:///./.cache/json/java-runtime-memory.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/java-runtime-memory.json","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","tags","pathContext","path"],"mappings":"AAAAA,cAAc,qBAERC,6EACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,YAAAC,OAAA,UAAsCC,gBAAmBC,GAAA,+HAAAC,KAAA,2kPAAkzHC,aAAy7HL,MAAA,sBAAAM,KAAA,oBAAAC,MAAA,iBAAiFC,aAAgBC,KAAA","file":"path---java-runtime-memory-1036eb202c89d7871d66.js","sourcesContent":["webpackJsonp([8034362812816101000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/java-runtime-memory.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Note Site\",\"author\":\"stone\"}},\"markdownRemark\":{\"id\":\"/home/peng/develop/workspace/stone-site/src/pages/2017-11-24-java-runtime-memory/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>JVM运行时的数据区域</h2>\\n<ul>\\n<li>\\n<p>程序计数器(Program Counter Register)</p>\\n<ol>\\n<li>一块比较小的内存空间,是当前线程所执行的字节码的<strong>行号指示器</strong></li>\\n<li>为了线程切换后能恢复到正确的执行位置,每个线程都需要有一个独立的程序计数器,即<strong>线程私有</strong></li>\\n<li>若正在执行的是一个Java方法,这个计数器记录的是当前正在执行的虚拟机字节码的地址</li>\\n<li>若正在执行的是Native方法,这个计数器则为空(Undefined)</li>\\n<li>唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域</li>\\n</ol>\\n</li>\\n<li>\\n<p>Java虚拟机栈(Java Virtual Machine Stacks)</p>\\n<ol>\\n<li>生命周期与线程相同,也是<strong>线程私有</strong>内存</li>\\n<li>用于描述<strong>Java方法</strong>执行的内存模型: 每个Java方法执行时会创建一个栈帧,\\n用于存储局部变量表,操作数栈,动态链接和方法出口等信息</li>\\n<li>若线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError;\\n若虚拟机栈可以动态扩展,当扩展时无法申请到足够的内存,将抛出OutOfMemoryError</li>\\n</ol>\\n</li>\\n<li>\\n<p>本地方法栈(Native Method Stack)</p>\\n<ol>\\n<li>Java虚拟机栈为Java方法(字节码)服务,而本地方法栈为Native方法服务</li>\\n<li>Sun HotSpot虚拟机把本地方法栈和虚拟机栈合二为一</li>\\n</ol>\\n</li>\\n<li>\\n<p>Java堆(Java Heap)</p>\\n<ol>\\n<li>一般来说,是Java虚拟机锁管理的内存中最大的一块,被所有线程共享</li>\\n<li>几乎所有的对象实例都在这里分配内存</li>\\n<li>是垃圾收集器管理的主要区域,也称作<strong>GC堆</strong>(Garbage Collected Heap)</li>\\n<li>若在堆中没有内存完成实例分配,也无法再扩展时,将抛出OutOfMemoryError</li>\\n</ol>\\n</li>\\n<li>\\n<p>方法区(Method Area)</p>\\n<ol>\\n<li>所有线程共享的内存区域</li>\\n<li>存储已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据</li>\\n<li>HotSpot虚拟机使用<strong>永久代</strong>(Permanent Generation)来实现方法区,\\n像管理Java堆一样管理这部分内存</li>\\n<li>永久代有<code>-XX:MaxPremSize</code>作为上限</li>\\n</ol>\\n</li>\\n</ul>\\n<h2>对象存活&#x26;死去</h2>\\n<ul>\\n<li>\\n<p>引用计数法(Reference Counting)</p>\\n<ol>\\n<li>基本思想:给对象添加一个引用计数器,当有一个地方引用它时,计数器加一;\\n当引用失效时,计数器减一. 计数器为零的对象即为<em>死去</em></li>\\n<li>无法解决对象之间<strong>循环引用</strong>的问题</li>\\n<li>主流的Java虚拟机都没用选用此方法来管理内存</li>\\n</ol>\\n</li>\\n<li>\\n<p>可达性分析算法(Reachability Analysis)</p>\\n<ol>\\n<li>基本思想:通过一系列的称为<strong>GC Roots</strong>的对象作为起始点,从这些节点向下搜索,\\n所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何\\n引用链相连时,证明此对象是不可用的(死去)</li>\\n<li>Java语言中,GC Roots包括以下几种:</li>\\n<li>虚拟机栈(栈帧中本地变量表)中引用的对象</li>\\n<li>方法区中的<strong>类静态属性</strong>引用的对象</li>\\n<li>方法区中的<strong>常量</strong>引用的对象</li>\\n<li>本地方法栈中(Native方法)引用的对象</li>\\n</ol>\\n</li>\\n</ul>\\n<h2>Java中的四种引用—强软弱虚</h2>\\n<ul>\\n<li>强引用(Strong Reference): 最常见的引用,只要强引用还在,就永远不会被回收</li>\\n<li>软引用(Soft Reference): 系统将要发生内存溢出异常之前,将会把软引用中的对象进行回收,\\n若这次回收仍没有释放足够的内存,才会抛出内存溢出异常</li>\\n<li>弱引用(Weak Reference): 只被弱引用关联的对象只能生存到下一次垃圾回收之前,即当垃圾收集器\\n工作时,总会回收掉只被弱引用关联的对象</li>\\n<li>虚引用(Phantom Reference): 最弱的一种引用关系,一个对象是否有虚引用的存在,完全不会对其\\n生存时间构成影响,也<strong>无法</strong>通过虚引用来获得一个对象实例.为一个对象设置虚引用关联的唯一\\n目的就是能在这个对象被收集器回收时收到一个系统通知</li>\\n</ul>\\n<h2>垃圾回收与finalize</h2>\\n<p>真正宣告一个对象死亡,至少要经过两次标记过程(<a href=\\\"/280b0addcf5163f1c2e7f1094e0404a7.java\\\">代码示例</a>):</p>\\n<ol>\\n<li>\\n<p>在可达性分析算法中不可达的对象,会被<strong>第一次标记</strong>为并且进行一次筛选:\\n筛选条件是是否有必要执行finalize方法(对象没有覆盖了finalize方法或者对象的这个方法\\n已经被虚拟机执行过,将视为<em>没有必要执行</em>)</p>\\n</li>\\n<li>\\n<p>如果被判定为有必要执行finalize()方法,那么对象会放置在F-Queue队列中,由一个低优先级的\\nFinalizer线程去执行它.稍后的GC将对F-Queue中的对象进行<strong>第二次标记</strong>,如果此时对象又\\n和引用链上的其他对象进行了关联(比如把this赋值给某个类变量),那么它将被移除出<em>即将回收的\\n集合</em>,否则将被真正回收</p>\\n</li>\\n</ol>\\n<h2>方法区中的垃圾回收</h2>\\n<ul>\\n<li>Java虚拟机规范<strong>不要求</strong>虚拟机实现方法区的垃圾收集</li>\\n<li>\\n<p>方法区(HotSpot中的永久代)中的垃圾收集主要有两部分内容:</p>\\n<ol>\\n<li>废弃常量: 收集方法与Java堆中的普通对象类似,如字符串常量<code>\\\"abc\\\"</code>,当系统中没有\\n一个String对象的值是<code>\\\"abc\\\"</code>,即没有其他地方引用了这个常量,那么它将被回收</li>\\n<li>\\n<p>无用的类: 一个类要<strong>同时满足</strong>以下三个条件算是无用的类 </p>\\n<ul>\\n<li>该类的所有实例都已经被回收</li>\\n<li>加载该类的classLoader已经被回收</li>\\n<li>该类对应的java.lang.Class对象没有在任何其他地方被引用,\\n无法在任何地方通过反射访问该类的方法</li>\\n</ul>\\n</li>\\n</ol>\\n</li>\\n</ul>\\n<h2>垃圾回收算法</h2>\\n<ul>\\n<li>\\n<p>标记-清除算法(Mark-Sweep)</p>\\n<ul>\\n<li>基本思路: 首先标记出所有需要回收的对象,在标记完成后统一回收</li>\\n<li>主要不足: 一是效率问题,标记和清除两个过程效率都不高;另一个是空间问题,\\n标记清除后会产生大量不连续的内存碎片</li>\\n</ul>\\n</li>\\n<li>\\n<p>复制算法(Copy)</p>\\n<ul>\\n<li>基本思路: 将内存按容量划分为大小相等的两块,每次只使用其中的一块;当这一块\\n的内存用完了,就将还存活着的对象复制到另一块上面,然后把已经使用过的那块内存\\n一次清理掉.</li>\\n<li>优点: 内存分配时不用考虑内存碎片的问题</li>\\n<li>缺点: 内存利用率较低,只利用了一半;对象存活率较高时复制操作太多</li>\\n<li>现在的商业虚拟机都采用这种算法来回收<strong>新生代</strong></li>\\n</ul>\\n</li>\\n<li>\\n<p>标记-整理算法(Mark-Compact)</p>\\n<ul>\\n<li>基本思路: 标记过程和就”标记-清除”算法一样,然后让所有存活的对象都向一端\\n移动,然后清理掉边界以外的内存</li>\\n<li>优点: 没有内存碎片</li>\\n<li>适用于<strong>老年代</strong></li>\\n</ul>\\n</li>\\n</ul>\\n<h2>垃圾收集器</h2>\\n<ul>\\n<li>\\n<p>Serial</p>\\n<ul>\\n<li>单线程: 不仅仅表示它只会用一个CPU或者一条线程过取去完成垃圾收集工作,\\n更重要的是它在进行垃圾收集时,必须暂停其他<strong>所有</strong>的工作线程,直到收集结束</li>\\n<li>使用<strong>复制</strong>算法</li>\\n<li>适用于桌面应用(Client模式),收集的内存不大,能在100ms內完成</li>\\n</ul>\\n</li>\\n<li>\\n<p>ParNew</p>\\n<ul>\\n<li>Serial收集器的多线程版本,可<strong>并行</strong>,使用<strong>复制</strong>算法</li>\\n<li>唯一能与CMS收集器配合工作的新生代收集器</li>\\n</ul>\\n</li>\\n<li>\\n<p>Parallel Scavenge</p>\\n<ul>\\n<li>新生代收集器,使用<strong>复制</strong>算法,可并行</li>\\n<li>与其他收集器不同,不关注<em>用户线程的停顿时间</em>,而是关注<strong>吞吐量</strong>\\n(运行用户代码时间/运行用户代码和垃圾收集的总时间)</li>\\n<li>适用于在后台计算而不需要太多交互的任务</li>\\n</ul>\\n</li>\\n<li>\\n<p>Serial Old</p>\\n<ul>\\n<li>Serial收集器的<strong>老年代</strong>版本,使用<strong>标记-清除</strong>算法</li>\\n<li>适用于桌面应用(Client模式)</li>\\n</ul>\\n</li>\\n<li>\\n<p>Parallel Old收集器</p>\\n<ul>\\n<li>Parallel Scavenge收集器的<strong>老年代</strong>版本,使用多线程和<strong>标记-整理</strong>算法</li>\\n</ul>\\n</li>\\n<li>\\n<p>CMS(Concurrent Mark Sweep)</p>\\n<ul>\\n<li>以获取<strong>最短回收停顿时间</strong>为目标的收集器,使用<strong>标记-清除</strong>算法</li>\\n<li>\\n<p>整个运作过程分为四个步骤</p>\\n<ol>\\n<li>初始标记(initial mark) - <code>stop the world</code> 时间很短</li>\\n<li>并发标记(concurrent mark) - 与用户线程并发 时间长</li>\\n<li>重新标记(remark) - <code>stop the world</code> 时间短</li>\\n<li>并发清除(concurrent sweep) - 与用户线程并发 时间长</li>\\n</ol>\\n</li>\\n<li>优点: 并发收集,低停顿</li>\\n<li>\\n<p>缺点:</p>\\n<ol>\\n<li>对CPU资源非常敏感,资源不足时用户程序执行速度下降明显</li>\\n<li>无法清理浮动垃圾</li>\\n<li>存在内存碎片(<code>标记-清除</code>算法)</li>\\n</ol>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>G1(Garbage first)</p>\\n<ul>\\n<li>前沿的成果之一,在HotSpot开发用于替代CMS</li>\\n<li>\\n<p>特点:</p>\\n<ol>\\n<li>并行与并发</li>\\n<li>分代收集</li>\\n<li>空间整合(整体看来基于<code>标记-清理</code>,没有内存碎片)</li>\\n<li>可预测的停顿(明确指定在长度为M毫秒的时间片段内GC时间不得超过N毫秒)</li>\\n</ol>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>GC类型</h2>\\n<ul>\\n<li>\\n<p>新生代GC(MinorGC / YoungGC): 发生在新生代的垃圾收集动作,非常频繁,速度较快</p>\\n</li>\\n<li>\\n<p>老年代GC(MajorGC / FullGC): 发生在老年代的GC,一般会伴随至少一次的MinorGC,\\n速度一般会比MinorGC慢十倍以上</p>\\n</li>\\n</ul>\\n<h2>内存分配与回收策略</h2>\\n<ul>\\n<li>对象优先在新生代Eden分配,没有足够空间时发起一次<strong>Minor GC</strong></li>\\n<li>大对象直接进入老年代</li>\\n<li>\\n<p>长期存活的对象将进入老年代</p>\\n<ul>\\n<li>每<code>熬过</code>一次MinorGC的对象年龄增加一岁</li>\\n<li>达到一定年龄(MaxTenuringThreshold,默认为15)的对象晋升到老年代</li>\\n</ul>\\n</li>\\n<li>\\n<p>动态对象年龄判定</p>\\n<ul>\\n<li>如果在Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半,\\n则年龄大于或者等于该年龄的对象就可以直接进入老年代,无需等到MaxTenuringThreshold</li>\\n</ul>\\n</li>\\n<li>\\n<p>空间分配担保</p>\\n<ul>\\n<li>每次发生MinorGC之前,会检查老年代<strong>最大可用连续空间</strong>是否大于新生代的所有空间</li>\\n<li>如果成立,则可以确保MinorGC是安全的</li>\\n<li>\\n<p>如果不成立,则检查HandlePromotionFailure(是否允许担保失败)</p>\\n<ul>\\n<li>HandlePromotionFailure为true,继续检查最大的可用连续空间\\n是否大于历次晋升到老年代对象的<strong>平均大小</strong></li>\\n<li>如果小于,或者HandlePromotionFailure为false,则改为进行FullGC</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Question</h2>\\n<ul>\\n<li>\\n<p>GC是什么?为什么要有GC</p>\\n</li>\\n<li>\\n<p>什么时候会导致垃圾回收</p>\\n</li>\\n<li>\\n<p>GC是怎么样运行的</p>\\n</li>\\n<li>\\n<p>新老以及永久区是什么</p>\\n</li>\\n<li>\\n<p>GC有几种方式？怎么配置</p>\\n</li>\\n<li>\\n<p>什么时候一个对象会被GC？ 如何判断一个对象是否存活</p>\\n</li>\\n<li>\\n<p>System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗</p>\\n</li>\\n<li>\\n<p>垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</p>\\n</li>\\n<li>\\n<p>Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生</p>\\n</li>\\n<li>\\n<p>垃圾回收算法的实现原理</p>\\n</li>\\n<li>\\n<p>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</p>\\n</li>\\n<li>\\n<p>垃圾回收的最佳做法是什么</p>\\n</li>\\n<li>\\n<p>GC收集器有哪些</p>\\n</li>\\n<li>\\n<p>垃圾回收器的基本原理是什么？</p>\\n</li>\\n<li>\\n<p>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么</p>\\n</li>\\n<li>\\n<p>Serial 与 Parallel GC之间的不同之处</p>\\n</li>\\n<li>\\n<p>CMS 收集器 与 G1 收集器的特点与区别</p>\\n</li>\\n<li>\\n<p>CMS垃圾回收器的工作过程</p>\\n</li>\\n<li>\\n<p>JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代</p>\\n</li>\\n<li>\\n<p>吞吐量优先和响应优先的垃圾收集器选择</p>\\n</li>\\n<li>\\n<p>举个实际的场景，选择一个GC策略</p>\\n</li>\\n<li>\\n<p>JVM的永久代中会发生垃圾回收吗</p>\\n</li>\\n<li>\\n<p>标记清除、标记整理、复制算法的原理与特点？分别用在什么地方</p>\\n</li>\\n<li>\\n<p>如果让你优化收集方法，有什么思路</p>\\n</li>\\n</ul>\",\"frontmatter\":{\"title\":\"Java Runtime Memory\",\"date\":\"November 24, 2017\",\"tags\":[\"java\",\"jvm\"]}}},\"pathContext\":{\"path\":\"/java-runtime-memory\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---java-runtime-memory-1036eb202c89d7871d66.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Note Site\",\"author\":\"stone\"}},\"markdownRemark\":{\"id\":\"/home/peng/develop/workspace/stone-site/src/pages/2017-11-24-java-runtime-memory/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>JVM运行时的数据区域</h2>\\n<ul>\\n<li>\\n<p>程序计数器(Program Counter Register)</p>\\n<ol>\\n<li>一块比较小的内存空间,是当前线程所执行的字节码的<strong>行号指示器</strong></li>\\n<li>为了线程切换后能恢复到正确的执行位置,每个线程都需要有一个独立的程序计数器,即<strong>线程私有</strong></li>\\n<li>若正在执行的是一个Java方法,这个计数器记录的是当前正在执行的虚拟机字节码的地址</li>\\n<li>若正在执行的是Native方法,这个计数器则为空(Undefined)</li>\\n<li>唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域</li>\\n</ol>\\n</li>\\n<li>\\n<p>Java虚拟机栈(Java Virtual Machine Stacks)</p>\\n<ol>\\n<li>生命周期与线程相同,也是<strong>线程私有</strong>内存</li>\\n<li>用于描述<strong>Java方法</strong>执行的内存模型: 每个Java方法执行时会创建一个栈帧,\\n用于存储局部变量表,操作数栈,动态链接和方法出口等信息</li>\\n<li>若线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError;\\n若虚拟机栈可以动态扩展,当扩展时无法申请到足够的内存,将抛出OutOfMemoryError</li>\\n</ol>\\n</li>\\n<li>\\n<p>本地方法栈(Native Method Stack)</p>\\n<ol>\\n<li>Java虚拟机栈为Java方法(字节码)服务,而本地方法栈为Native方法服务</li>\\n<li>Sun HotSpot虚拟机把本地方法栈和虚拟机栈合二为一</li>\\n</ol>\\n</li>\\n<li>\\n<p>Java堆(Java Heap)</p>\\n<ol>\\n<li>一般来说,是Java虚拟机锁管理的内存中最大的一块,被所有线程共享</li>\\n<li>几乎所有的对象实例都在这里分配内存</li>\\n<li>是垃圾收集器管理的主要区域,也称作<strong>GC堆</strong>(Garbage Collected Heap)</li>\\n<li>若在堆中没有内存完成实例分配,也无法再扩展时,将抛出OutOfMemoryError</li>\\n</ol>\\n</li>\\n<li>\\n<p>方法区(Method Area)</p>\\n<ol>\\n<li>所有线程共享的内存区域</li>\\n<li>存储已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据</li>\\n<li>HotSpot虚拟机使用<strong>永久代</strong>(Permanent Generation)来实现方法区,\\n像管理Java堆一样管理这部分内存</li>\\n<li>永久代有<code>-XX:MaxPremSize</code>作为上限</li>\\n</ol>\\n</li>\\n</ul>\\n<h2>对象存活&#x26;死去</h2>\\n<ul>\\n<li>\\n<p>引用计数法(Reference Counting)</p>\\n<ol>\\n<li>基本思想:给对象添加一个引用计数器,当有一个地方引用它时,计数器加一;\\n当引用失效时,计数器减一. 计数器为零的对象即为<em>死去</em></li>\\n<li>无法解决对象之间<strong>循环引用</strong>的问题</li>\\n<li>主流的Java虚拟机都没用选用此方法来管理内存</li>\\n</ol>\\n</li>\\n<li>\\n<p>可达性分析算法(Reachability Analysis)</p>\\n<ol>\\n<li>基本思想:通过一系列的称为<strong>GC Roots</strong>的对象作为起始点,从这些节点向下搜索,\\n所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何\\n引用链相连时,证明此对象是不可用的(死去)</li>\\n<li>Java语言中,GC Roots包括以下几种:</li>\\n<li>虚拟机栈(栈帧中本地变量表)中引用的对象</li>\\n<li>方法区中的<strong>类静态属性</strong>引用的对象</li>\\n<li>方法区中的<strong>常量</strong>引用的对象</li>\\n<li>本地方法栈中(Native方法)引用的对象</li>\\n</ol>\\n</li>\\n</ul>\\n<h2>Java中的四种引用—强软弱虚</h2>\\n<ul>\\n<li>强引用(Strong Reference): 最常见的引用,只要强引用还在,就永远不会被回收</li>\\n<li>软引用(Soft Reference): 系统将要发生内存溢出异常之前,将会把软引用中的对象进行回收,\\n若这次回收仍没有释放足够的内存,才会抛出内存溢出异常</li>\\n<li>弱引用(Weak Reference): 只被弱引用关联的对象只能生存到下一次垃圾回收之前,即当垃圾收集器\\n工作时,总会回收掉只被弱引用关联的对象</li>\\n<li>虚引用(Phantom Reference): 最弱的一种引用关系,一个对象是否有虚引用的存在,完全不会对其\\n生存时间构成影响,也<strong>无法</strong>通过虚引用来获得一个对象实例.为一个对象设置虚引用关联的唯一\\n目的就是能在这个对象被收集器回收时收到一个系统通知</li>\\n</ul>\\n<h2>垃圾回收与finalize</h2>\\n<p>真正宣告一个对象死亡,至少要经过两次标记过程(<a href=\\\"/280b0addcf5163f1c2e7f1094e0404a7.java\\\">代码示例</a>):</p>\\n<ol>\\n<li>\\n<p>在可达性分析算法中不可达的对象,会被<strong>第一次标记</strong>为并且进行一次筛选:\\n筛选条件是是否有必要执行finalize方法(对象没有覆盖了finalize方法或者对象的这个方法\\n已经被虚拟机执行过,将视为<em>没有必要执行</em>)</p>\\n</li>\\n<li>\\n<p>如果被判定为有必要执行finalize()方法,那么对象会放置在F-Queue队列中,由一个低优先级的\\nFinalizer线程去执行它.稍后的GC将对F-Queue中的对象进行<strong>第二次标记</strong>,如果此时对象又\\n和引用链上的其他对象进行了关联(比如把this赋值给某个类变量),那么它将被移除出<em>即将回收的\\n集合</em>,否则将被真正回收</p>\\n</li>\\n</ol>\\n<h2>方法区中的垃圾回收</h2>\\n<ul>\\n<li>Java虚拟机规范<strong>不要求</strong>虚拟机实现方法区的垃圾收集</li>\\n<li>\\n<p>方法区(HotSpot中的永久代)中的垃圾收集主要有两部分内容:</p>\\n<ol>\\n<li>废弃常量: 收集方法与Java堆中的普通对象类似,如字符串常量<code>\\\"abc\\\"</code>,当系统中没有\\n一个String对象的值是<code>\\\"abc\\\"</code>,即没有其他地方引用了这个常量,那么它将被回收</li>\\n<li>\\n<p>无用的类: 一个类要<strong>同时满足</strong>以下三个条件算是无用的类 </p>\\n<ul>\\n<li>该类的所有实例都已经被回收</li>\\n<li>加载该类的classLoader已经被回收</li>\\n<li>该类对应的java.lang.Class对象没有在任何其他地方被引用,\\n无法在任何地方通过反射访问该类的方法</li>\\n</ul>\\n</li>\\n</ol>\\n</li>\\n</ul>\\n<h2>垃圾回收算法</h2>\\n<ul>\\n<li>\\n<p>标记-清除算法(Mark-Sweep)</p>\\n<ul>\\n<li>基本思路: 首先标记出所有需要回收的对象,在标记完成后统一回收</li>\\n<li>主要不足: 一是效率问题,标记和清除两个过程效率都不高;另一个是空间问题,\\n标记清除后会产生大量不连续的内存碎片</li>\\n</ul>\\n</li>\\n<li>\\n<p>复制算法(Copy)</p>\\n<ul>\\n<li>基本思路: 将内存按容量划分为大小相等的两块,每次只使用其中的一块;当这一块\\n的内存用完了,就将还存活着的对象复制到另一块上面,然后把已经使用过的那块内存\\n一次清理掉.</li>\\n<li>优点: 内存分配时不用考虑内存碎片的问题</li>\\n<li>缺点: 内存利用率较低,只利用了一半;对象存活率较高时复制操作太多</li>\\n<li>现在的商业虚拟机都采用这种算法来回收<strong>新生代</strong></li>\\n</ul>\\n</li>\\n<li>\\n<p>标记-整理算法(Mark-Compact)</p>\\n<ul>\\n<li>基本思路: 标记过程和就”标记-清除”算法一样,然后让所有存活的对象都向一端\\n移动,然后清理掉边界以外的内存</li>\\n<li>优点: 没有内存碎片</li>\\n<li>适用于<strong>老年代</strong></li>\\n</ul>\\n</li>\\n</ul>\\n<h2>垃圾收集器</h2>\\n<ul>\\n<li>\\n<p>Serial</p>\\n<ul>\\n<li>单线程: 不仅仅表示它只会用一个CPU或者一条线程过取去完成垃圾收集工作,\\n更重要的是它在进行垃圾收集时,必须暂停其他<strong>所有</strong>的工作线程,直到收集结束</li>\\n<li>使用<strong>复制</strong>算法</li>\\n<li>适用于桌面应用(Client模式),收集的内存不大,能在100ms內完成</li>\\n</ul>\\n</li>\\n<li>\\n<p>ParNew</p>\\n<ul>\\n<li>Serial收集器的多线程版本,可<strong>并行</strong>,使用<strong>复制</strong>算法</li>\\n<li>唯一能与CMS收集器配合工作的新生代收集器</li>\\n</ul>\\n</li>\\n<li>\\n<p>Parallel Scavenge</p>\\n<ul>\\n<li>新生代收集器,使用<strong>复制</strong>算法,可并行</li>\\n<li>与其他收集器不同,不关注<em>用户线程的停顿时间</em>,而是关注<strong>吞吐量</strong>\\n(运行用户代码时间/运行用户代码和垃圾收集的总时间)</li>\\n<li>适用于在后台计算而不需要太多交互的任务</li>\\n</ul>\\n</li>\\n<li>\\n<p>Serial Old</p>\\n<ul>\\n<li>Serial收集器的<strong>老年代</strong>版本,使用<strong>标记-清除</strong>算法</li>\\n<li>适用于桌面应用(Client模式)</li>\\n</ul>\\n</li>\\n<li>\\n<p>Parallel Old收集器</p>\\n<ul>\\n<li>Parallel Scavenge收集器的<strong>老年代</strong>版本,使用多线程和<strong>标记-整理</strong>算法</li>\\n</ul>\\n</li>\\n<li>\\n<p>CMS(Concurrent Mark Sweep)</p>\\n<ul>\\n<li>以获取<strong>最短回收停顿时间</strong>为目标的收集器,使用<strong>标记-清除</strong>算法</li>\\n<li>\\n<p>整个运作过程分为四个步骤</p>\\n<ol>\\n<li>初始标记(initial mark) - <code>stop the world</code> 时间很短</li>\\n<li>并发标记(concurrent mark) - 与用户线程并发 时间长</li>\\n<li>重新标记(remark) - <code>stop the world</code> 时间短</li>\\n<li>并发清除(concurrent sweep) - 与用户线程并发 时间长</li>\\n</ol>\\n</li>\\n<li>优点: 并发收集,低停顿</li>\\n<li>\\n<p>缺点:</p>\\n<ol>\\n<li>对CPU资源非常敏感,资源不足时用户程序执行速度下降明显</li>\\n<li>无法清理浮动垃圾</li>\\n<li>存在内存碎片(<code>标记-清除</code>算法)</li>\\n</ol>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>G1(Garbage first)</p>\\n<ul>\\n<li>前沿的成果之一,在HotSpot开发用于替代CMS</li>\\n<li>\\n<p>特点:</p>\\n<ol>\\n<li>并行与并发</li>\\n<li>分代收集</li>\\n<li>空间整合(整体看来基于<code>标记-清理</code>,没有内存碎片)</li>\\n<li>可预测的停顿(明确指定在长度为M毫秒的时间片段内GC时间不得超过N毫秒)</li>\\n</ol>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>GC类型</h2>\\n<ul>\\n<li>\\n<p>新生代GC(MinorGC / YoungGC): 发生在新生代的垃圾收集动作,非常频繁,速度较快</p>\\n</li>\\n<li>\\n<p>老年代GC(MajorGC / FullGC): 发生在老年代的GC,一般会伴随至少一次的MinorGC,\\n速度一般会比MinorGC慢十倍以上</p>\\n</li>\\n</ul>\\n<h2>内存分配与回收策略</h2>\\n<ul>\\n<li>对象优先在新生代Eden分配,没有足够空间时发起一次<strong>Minor GC</strong></li>\\n<li>大对象直接进入老年代</li>\\n<li>\\n<p>长期存活的对象将进入老年代</p>\\n<ul>\\n<li>每<code>熬过</code>一次MinorGC的对象年龄增加一岁</li>\\n<li>达到一定年龄(MaxTenuringThreshold,默认为15)的对象晋升到老年代</li>\\n</ul>\\n</li>\\n<li>\\n<p>动态对象年龄判定</p>\\n<ul>\\n<li>如果在Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半,\\n则年龄大于或者等于该年龄的对象就可以直接进入老年代,无需等到MaxTenuringThreshold</li>\\n</ul>\\n</li>\\n<li>\\n<p>空间分配担保</p>\\n<ul>\\n<li>每次发生MinorGC之前,会检查老年代<strong>最大可用连续空间</strong>是否大于新生代的所有空间</li>\\n<li>如果成立,则可以确保MinorGC是安全的</li>\\n<li>\\n<p>如果不成立,则检查HandlePromotionFailure(是否允许担保失败)</p>\\n<ul>\\n<li>HandlePromotionFailure为true,继续检查最大的可用连续空间\\n是否大于历次晋升到老年代对象的<strong>平均大小</strong></li>\\n<li>如果小于,或者HandlePromotionFailure为false,则改为进行FullGC</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n<h2>Question</h2>\\n<ul>\\n<li>\\n<p>GC是什么?为什么要有GC</p>\\n</li>\\n<li>\\n<p>什么时候会导致垃圾回收</p>\\n</li>\\n<li>\\n<p>GC是怎么样运行的</p>\\n</li>\\n<li>\\n<p>新老以及永久区是什么</p>\\n</li>\\n<li>\\n<p>GC有几种方式？怎么配置</p>\\n</li>\\n<li>\\n<p>什么时候一个对象会被GC？ 如何判断一个对象是否存活</p>\\n</li>\\n<li>\\n<p>System.gc() Runtime.gc()会做什么事情？ 能保证 GC 执行吗</p>\\n</li>\\n<li>\\n<p>垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</p>\\n</li>\\n<li>\\n<p>Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生</p>\\n</li>\\n<li>\\n<p>垃圾回收算法的实现原理</p>\\n</li>\\n<li>\\n<p>如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</p>\\n</li>\\n<li>\\n<p>垃圾回收的最佳做法是什么</p>\\n</li>\\n<li>\\n<p>GC收集器有哪些</p>\\n</li>\\n<li>\\n<p>垃圾回收器的基本原理是什么？</p>\\n</li>\\n<li>\\n<p>串行(serial)收集器和吞吐量(throughput)收集器的区别是什么</p>\\n</li>\\n<li>\\n<p>Serial 与 Parallel GC之间的不同之处</p>\\n</li>\\n<li>\\n<p>CMS 收集器 与 G1 收集器的特点与区别</p>\\n</li>\\n<li>\\n<p>CMS垃圾回收器的工作过程</p>\\n</li>\\n<li>\\n<p>JVM 中一次完整的 GC 流程是怎样的？ 对象如何晋升到老年代</p>\\n</li>\\n<li>\\n<p>吞吐量优先和响应优先的垃圾收集器选择</p>\\n</li>\\n<li>\\n<p>举个实际的场景，选择一个GC策略</p>\\n</li>\\n<li>\\n<p>JVM的永久代中会发生垃圾回收吗</p>\\n</li>\\n<li>\\n<p>标记清除、标记整理、复制算法的原理与特点？分别用在什么地方</p>\\n</li>\\n<li>\\n<p>如果让你优化收集方法，有什么思路</p>\\n</li>\\n</ul>\",\"frontmatter\":{\"title\":\"Java Runtime Memory\",\"date\":\"November 24, 2017\",\"tags\":[\"java\",\"jvm\"]}}},\"pathContext\":{\"path\":\"/java-runtime-memory\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/java-runtime-memory.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/java-runtime-memory.json\n// module chunks = 8034362812816101000"],"sourceRoot":""}