{"version":3,"sources":["webpack:///path---index-72e378f34badd07d97bd.js","webpack:///./.cache/json/index.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/index.json","module","exports","data","site","siteMetadata","title","allMarkdownRemark","edges","node","excerpt","frontmatter","path","date","pathContext"],"mappings":"AAAAA,cAAc,qBAERC,+DACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,cAAqBC,mBAAsBC,QAAUC,MAAQC,QAAA,wIAAAC,aAAiKC,KAAA,qBAAAC,KAAA,oBAAAP,MAAA,wBAAuFG,MAAQC,QAAA,6FAAAC,aAAsHC,KAAA,oBAAAC,KAAA,oBAAAP,MAAA,uBAAqFG,MAAQC,QAAA,yHAAAC,aAAkJC,KAAA,aAAAC,KAAA,oBAAAP,MAAA,gBAAuEG,MAAQC,QAAA,sIAAAC,aAA+JC,KAAA,eAAAC,KAAA,oBAAAP,MAAA,kBAA2EG,MAAQC,QAAA,yCAAAC,aAAkEC,KAAA,sBAAAC,KAAA,oBAAAP,MAAA,yBAAyFG,MAAQC,QAAA,kEAAAC,aAA2FC,KAAA,iCAAAC,KAAA,oBAAAP,MAAA,gCAA2GG,MAAQC,QAAA,0GAAAC,aAAmIC,KAAA,qBAAAC,KAAA,oBAAAP,MAAA,wBAAuFG,MAAQC,QAAA,uGAAAC,aAAgIC,KAAA,4BAAAC,KAAA,oBAAAP,MAAA,6BAAmGG,MAAQC,QAAA,gJAAAC,aAAyKC,KAAA,uBAAAC,KAAA,oBAAAP,MAAA,yBAA0FG,MAAQC,QAAA,yEAAAC,aAAkGC,KAAA,iBAAAC,KAAA,oBAAAP,MAAA,mBAA8EG,MAAQC,QAAA,kGAAAC,aAA2HC,KAAA,wBAAAC,KAAA,oBAAAP,MAAA,yBAA2FG,MAAQC,QAAA,oIAAAC,aAA6JC,KAAA,mBAAAC,KAAA,oBAAAP,MAAA,qBAAkFG,MAAQC,QAAA,iBAAAC,aAA0CC,KAAA,kBAAAC,KAAA,oBAAAP,MAAA,qBAAiFG,MAAQC,QAAA,iJAAAC,aAA0KC,KAAA,oBAAAC,KAAA,oBAAAP,MAAA,sBAAoFG,MAAQC,QAAA,+IAAAC,aAAwKC,KAAA,oBAAAC,KAAA,oBAAAP,MAAA,mBAAiFG,MAAQC,QAAA,kJAAAC,aAA2KC,KAAA,oBAAAC,KAAA,oBAAAP,MAAA,sBAAoFG,MAAQC,QAAA,2IAAAC,aAAoKC,KAAA,YAAAC,KAAA,qBAAAP,MAAA,eAAsEG,MAAQC,QAAA,sDAAAC,aAA+EC,KAAA,6BAAAC,KAAA,qBAAAP,MAAA,gCAAwGG,MAAQC,QAAA,yIAAAC,aAAkKC,KAAA,mBAAAC,KAAA,qBAAAP,MAAA,qBAAmFG,MAAQC,QAAA,2IAAAC,aAAoKC,KAAA,kBAAAC,KAAA,qBAAAP,MAAA,qBAAkFG,MAAQC,QAAA,8IAAAC,aAAuKC,KAAA,qBAAAC,KAAA,qBAAAP,MAAA,uBAAuFG,MAAQC,QAAA,qHAAAC,aAA8IC,KAAA,qBAAAC,KAAA,qBAAAP,MAAA,wBAAwFG,MAAQC,QAAA,kJAAAC,aAA2KC,KAAA,aAAAC,KAAA,eAAAP,MAAA,uBAAwEQ","file":"path---index-72e378f34badd07d97bd.js","sourcesContent":["webpackJsonp([9347362237655822000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/index.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Note Site\"}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"excerpt\":\"Java Thread Local 线程封闭 当访问共享的可变数据时,通常需要使用同步.一种避免使用同步的方式就是不共享数据,如果仅在单线程内访问数据,\\n就不需要同步,这种数据被称为 线程封闭 (Thread Confinement) ThreadLocal...\",\"frontmatter\":{\"path\":\"/java-thread-local\",\"date\":\"20 November, 2017\",\"title\":\"Java Thread Local\"}}},{\"node\":{\"excerpt\":\"Java Thread Pool Java中的线程池是运用场景最多的并发框架,几乎所有需要异步或并发执行任务的程序\\n都可以使用线程池。在开发过程中,合理地使用线程池能够带来...\",\"frontmatter\":{\"path\":\"/java-thread-pool\",\"date\":\"19 November, 2017\",\"title\":\"Java Thread Pool\"}}},{\"node\":{\"excerpt\":\"synchronized对比Lock lock获取锁的过程比较可控,粒度更细,synchronize获得锁的过程由jvm控制 synchronize会自动释放锁,lock释放锁需要显式调用 synchronized关键字 Java...\",\"frontmatter\":{\"path\":\"/java-lock\",\"date\":\"17 November, 2017\",\"title\":\"Java Lock\"}}},{\"node\":{\"excerpt\":\"Thread Java中的线程在运行的生命在周期中可能处于以下6个状态之一 new 初始状态,线程被构建,但是还没有调用start()方法 runnable 运行状态,Java线程将操作系统中的 就绪 和 运行 两种状态都笼统的称作 运行中 blocked...\",\"frontmatter\":{\"path\":\"/java-thread\",\"date\":\"17 November, 2017\",\"title\":\"Java Thread\"}}},{\"node\":{\"excerpt\":\"Java Serialization 详阅< >18章12节 Java...\",\"frontmatter\":{\"path\":\"/java-serialization\",\"date\":\"16 November, 2017\",\"title\":\"Java Serialization\"}}},{\"node\":{\"excerpt\":\"CopyOnWriteArrayList add E set(int index, E element) remove get\",\"frontmatter\":{\"path\":\"/java-copy-on-write-array-list\",\"date\":\"14 November, 2017\",\"title\":\"Java CopyOnWriteArrayList\"}}},{\"node\":{\"excerpt\":\"Java Memory Model 从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）\\nJSR-133提出了happens-before...\",\"frontmatter\":{\"path\":\"/java-memory-model\",\"date\":\"14 November, 2017\",\"title\":\"Java Memory Model\"}}},{\"node\":{\"excerpt\":\"Java ConcurrentHashMap Node fields size() public V put(K key, V value) transfer 扩容方法 基本思想和HashMap...\",\"frontmatter\":{\"path\":\"/java-concurrent-hash-map\",\"date\":\"13 November, 2017\",\"title\":\"Java ConcurrentHashMap\"}}},{\"node\":{\"excerpt\":\"PriorityQueue 优先队列,能保证每次取出来的元素都是队列中权值最小的(C++中每次取最大的元素) 元素大小比较可使用构造时传入的比较器或者使用元素的自然顺序(natural order) 不允许放入null元素 通过完全二叉树实现的最小堆,底层通过数组实现 add...\",\"frontmatter\":{\"path\":\"/java-priority-queue\",\"date\":\"11 November, 2017\",\"title\":\"Java PriorityQueue\"}}},{\"node\":{\"excerpt\":\"Java TreeMap 实现了SortedMap接口,会按照key的大小对map中的元素进行排序 未实现同步(不是线程安全) key...\",\"frontmatter\":{\"path\":\"/java-tree-map\",\"date\":\"10 November, 2017\",\"title\":\"Java TreeMap\"}}},{\"node\":{\"excerpt\":\"Java LinkedHashMap HashMap的直接子类 在HashMap的基础上，采用双向链表将所有的entry链接起来 能保证迭代顺序与插入顺序相同 未实现同步（不是线程安全） *\",\"frontmatter\":{\"path\":\"/java-linked-hash-map\",\"date\":\"08 November, 2017\",\"title\":\"Java LinkedHashMap\"}}},{\"node\":{\"excerpt\":\"Java Hashtable 抽象父类为Dictionary (一个过时的类) 实现同步（线程安全） key和value都不允许为空 put() put方法用 关键字实现同步 判断value是否为空,为空则抛出异常 直接计算key对象的hashCode...\",\"frontmatter\":{\"path\":\"/java-hash-table\",\"date\":\"08 November, 2017\",\"title\":\"Java Hashtable\"}}},{\"node\":{\"excerpt\":\"SQL Table Join\",\"frontmatter\":{\"path\":\"/sql-table-join\",\"date\":\"06 November, 2017\",\"title\":\"SQL Table Join\"}}},{\"node\":{\"excerpt\":\"Java ArrayDeque ArrayDeque和LinkedList是Deque的两个通用实现，\\n官方更推荐使用AarryDeque用作栈和队列. 底层通过 循环数组(circular array) 实现 不允许插入null元素 没有实现同步(不是线程安全) 　void...\",\"frontmatter\":{\"path\":\"/java-array-deque\",\"date\":\"04 November, 2017\",\"title\":\"Java ArrayDeque\"}}},{\"node\":{\"excerpt\":\"Java HashMap Map的最常用实现 允许放入空元素 (key允许为空,value也允许为空) 不保证元素的顺序 未实现同步（不是线程安全） get() hash()函数: 取原对象的hashCode,左移16位,返回与其自身的亦或结果\\n原因: 因为HashMap...\",\"frontmatter\":{\"path\":\"/java-array-deque\",\"date\":\"04 November, 2017\",\"title\":\"Java HashMap\"}}},{\"node\":{\"excerpt\":\"Java LinkedList LinkedList同时实现了List和Deque接口 可以当做队列(Queue)或栈(Stack)使用,虽然首选还是ArrayDeque 没有实现同步 底层通过 双向链表实现 链表节点为内部类Node,LinkedList通过first和last...\",\"frontmatter\":{\"path\":\"/java-linked-list\",\"date\":\"03 November, 2017\",\"title\":\"Java LinkedList\"}}},{\"node\":{\"excerpt\":\"ASCII American Standard Code for Information Interchange，美国信息互换标准代码）\\n最常见的英文编码，标准的ASCII码表是128个字符,\\n范围是0x00~0x7F (0000 0000 ~ 0111 111...\",\"frontmatter\":{\"path\":\"/encoding\",\"date\":\"12 September, 2017\",\"title\":\"Encoding\"}}},{\"node\":{\"excerpt\":\"Java Collection Framework interface Queue interface\",\"frontmatter\":{\"path\":\"/java-collection-framework\",\"date\":\"12 September, 2017\",\"title\":\"Java Collection Framework\"}}},{\"node\":{\"excerpt\":\"Java ArrayList Java中最常用的数据结构之一 元素的存放顺序与 的顺序相同 允许放入 元素 未实现同步（不是线程安全） 底层实现是一个array数组 由于java中的数组无法自动扩容，所以当ArrayList中的容量 不足时，\\n会调用 函数进行扩容。\",\"frontmatter\":{\"path\":\"/java-array-list\",\"date\":\"12 September, 2017\",\"title\":\"java ArrayList\"}}},{\"node\":{\"excerpt\":\"代码区块 标记方法 用三个反引号 ` ` ` 包围 只有声明了程序语言的代码块才会应用语法高亮 缩进4个空格或者1个制表符 行内代码，用单个反引号 ` 包起来 标记效果 区块会被 和 标签包裹 区块中      会自动转成html实体  区块中各种markdown语法无效\",\"frontmatter\":{\"path\":\"/code-highlight\",\"date\":\"10 September, 2017\",\"title\":\"Code Highlight\"}}},{\"node\":{\"excerpt\":\"Java中的类加载时机 遇到      或者  这四种字节码指令时，对类进行初始化\\n 可以认定为一种特殊的静态方法 使用反射方法对类进行反射调用的时候 当初始化一个类的时候，自动初始化其父类 当虚拟机启动时，会触发执行主类（包含main方法的那个类）的初始化 使用JDK...\",\"frontmatter\":{\"path\":\"/java-classloader/\",\"date\":\"05 September, 2017\",\"title\":\"Java Classloader\"}}},{\"node\":{\"excerpt\":\"页面内的快速跳转 标题    分割线    强调    列表    链接    图片    表格    脚注    引用    行内HTML    分割线 标题 H1 H2 H3 H4 H5 H6 Alt-H1 Alt-H...\",\"frontmatter\":{\"path\":\"/markdown-learning\",\"date\":\"05 September, 2017\",\"title\":\"Markdown Learning\"}}},{\"node\":{\"excerpt\":\"Far far away, behind the word mountains, far from the countries Vokalia\\nand Consonantia, there live the blind texts. Separated they live in...\",\"frontmatter\":{\"path\":\"/hi-folks/\",\"date\":\"28 May, 2015\",\"title\":\"New Beginnings\"}}}]}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---index-72e378f34badd07d97bd.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Note Site\"}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"excerpt\":\"Java Thread Local 线程封闭 当访问共享的可变数据时,通常需要使用同步.一种避免使用同步的方式就是不共享数据,如果仅在单线程内访问数据,\\n就不需要同步,这种数据被称为 线程封闭 (Thread Confinement) ThreadLocal...\",\"frontmatter\":{\"path\":\"/java-thread-local\",\"date\":\"20 November, 2017\",\"title\":\"Java Thread Local\"}}},{\"node\":{\"excerpt\":\"Java Thread Pool Java中的线程池是运用场景最多的并发框架,几乎所有需要异步或并发执行任务的程序\\n都可以使用线程池。在开发过程中,合理地使用线程池能够带来...\",\"frontmatter\":{\"path\":\"/java-thread-pool\",\"date\":\"19 November, 2017\",\"title\":\"Java Thread Pool\"}}},{\"node\":{\"excerpt\":\"synchronized对比Lock lock获取锁的过程比较可控,粒度更细,synchronize获得锁的过程由jvm控制 synchronize会自动释放锁,lock释放锁需要显式调用 synchronized关键字 Java...\",\"frontmatter\":{\"path\":\"/java-lock\",\"date\":\"17 November, 2017\",\"title\":\"Java Lock\"}}},{\"node\":{\"excerpt\":\"Thread Java中的线程在运行的生命在周期中可能处于以下6个状态之一 new 初始状态,线程被构建,但是还没有调用start()方法 runnable 运行状态,Java线程将操作系统中的 就绪 和 运行 两种状态都笼统的称作 运行中 blocked...\",\"frontmatter\":{\"path\":\"/java-thread\",\"date\":\"17 November, 2017\",\"title\":\"Java Thread\"}}},{\"node\":{\"excerpt\":\"Java Serialization 详阅< >18章12节 Java...\",\"frontmatter\":{\"path\":\"/java-serialization\",\"date\":\"16 November, 2017\",\"title\":\"Java Serialization\"}}},{\"node\":{\"excerpt\":\"CopyOnWriteArrayList add E set(int index, E element) remove get\",\"frontmatter\":{\"path\":\"/java-copy-on-write-array-list\",\"date\":\"14 November, 2017\",\"title\":\"Java CopyOnWriteArrayList\"}}},{\"node\":{\"excerpt\":\"Java Memory Model 从JDK5开始，java使用新的JSR -133内存模型（本文除非特别说明，针对的都是JSR- 133内存模型）\\nJSR-133提出了happens-before...\",\"frontmatter\":{\"path\":\"/java-memory-model\",\"date\":\"14 November, 2017\",\"title\":\"Java Memory Model\"}}},{\"node\":{\"excerpt\":\"Java ConcurrentHashMap Node fields size() public V put(K key, V value) transfer 扩容方法 基本思想和HashMap...\",\"frontmatter\":{\"path\":\"/java-concurrent-hash-map\",\"date\":\"13 November, 2017\",\"title\":\"Java ConcurrentHashMap\"}}},{\"node\":{\"excerpt\":\"PriorityQueue 优先队列,能保证每次取出来的元素都是队列中权值最小的(C++中每次取最大的元素) 元素大小比较可使用构造时传入的比较器或者使用元素的自然顺序(natural order) 不允许放入null元素 通过完全二叉树实现的最小堆,底层通过数组实现 add...\",\"frontmatter\":{\"path\":\"/java-priority-queue\",\"date\":\"11 November, 2017\",\"title\":\"Java PriorityQueue\"}}},{\"node\":{\"excerpt\":\"Java TreeMap 实现了SortedMap接口,会按照key的大小对map中的元素进行排序 未实现同步(不是线程安全) key...\",\"frontmatter\":{\"path\":\"/java-tree-map\",\"date\":\"10 November, 2017\",\"title\":\"Java TreeMap\"}}},{\"node\":{\"excerpt\":\"Java LinkedHashMap HashMap的直接子类 在HashMap的基础上，采用双向链表将所有的entry链接起来 能保证迭代顺序与插入顺序相同 未实现同步（不是线程安全） *\",\"frontmatter\":{\"path\":\"/java-linked-hash-map\",\"date\":\"08 November, 2017\",\"title\":\"Java LinkedHashMap\"}}},{\"node\":{\"excerpt\":\"Java Hashtable 抽象父类为Dictionary (一个过时的类) 实现同步（线程安全） key和value都不允许为空 put() put方法用 关键字实现同步 判断value是否为空,为空则抛出异常 直接计算key对象的hashCode...\",\"frontmatter\":{\"path\":\"/java-hash-table\",\"date\":\"08 November, 2017\",\"title\":\"Java Hashtable\"}}},{\"node\":{\"excerpt\":\"SQL Table Join\",\"frontmatter\":{\"path\":\"/sql-table-join\",\"date\":\"06 November, 2017\",\"title\":\"SQL Table Join\"}}},{\"node\":{\"excerpt\":\"Java ArrayDeque ArrayDeque和LinkedList是Deque的两个通用实现，\\n官方更推荐使用AarryDeque用作栈和队列. 底层通过 循环数组(circular array) 实现 不允许插入null元素 没有实现同步(不是线程安全) 　void...\",\"frontmatter\":{\"path\":\"/java-array-deque\",\"date\":\"04 November, 2017\",\"title\":\"Java ArrayDeque\"}}},{\"node\":{\"excerpt\":\"Java HashMap Map的最常用实现 允许放入空元素 (key允许为空,value也允许为空) 不保证元素的顺序 未实现同步（不是线程安全） get() hash()函数: 取原对象的hashCode,左移16位,返回与其自身的亦或结果\\n原因: 因为HashMap...\",\"frontmatter\":{\"path\":\"/java-array-deque\",\"date\":\"04 November, 2017\",\"title\":\"Java HashMap\"}}},{\"node\":{\"excerpt\":\"Java LinkedList LinkedList同时实现了List和Deque接口 可以当做队列(Queue)或栈(Stack)使用,虽然首选还是ArrayDeque 没有实现同步 底层通过 双向链表实现 链表节点为内部类Node,LinkedList通过first和last...\",\"frontmatter\":{\"path\":\"/java-linked-list\",\"date\":\"03 November, 2017\",\"title\":\"Java LinkedList\"}}},{\"node\":{\"excerpt\":\"ASCII American Standard Code for Information Interchange，美国信息互换标准代码）\\n最常见的英文编码，标准的ASCII码表是128个字符,\\n范围是0x00~0x7F (0000 0000 ~ 0111 111...\",\"frontmatter\":{\"path\":\"/encoding\",\"date\":\"12 September, 2017\",\"title\":\"Encoding\"}}},{\"node\":{\"excerpt\":\"Java Collection Framework interface Queue interface\",\"frontmatter\":{\"path\":\"/java-collection-framework\",\"date\":\"12 September, 2017\",\"title\":\"Java Collection Framework\"}}},{\"node\":{\"excerpt\":\"Java ArrayList Java中最常用的数据结构之一 元素的存放顺序与 的顺序相同 允许放入 元素 未实现同步（不是线程安全） 底层实现是一个array数组 由于java中的数组无法自动扩容，所以当ArrayList中的容量 不足时，\\n会调用 函数进行扩容。\",\"frontmatter\":{\"path\":\"/java-array-list\",\"date\":\"12 September, 2017\",\"title\":\"java ArrayList\"}}},{\"node\":{\"excerpt\":\"代码区块 标记方法 用三个反引号 ` ` ` 包围 只有声明了程序语言的代码块才会应用语法高亮 缩进4个空格或者1个制表符 行内代码，用单个反引号 ` 包起来 标记效果 区块会被 和 标签包裹 区块中      会自动转成html实体  区块中各种markdown语法无效\",\"frontmatter\":{\"path\":\"/code-highlight\",\"date\":\"10 September, 2017\",\"title\":\"Code Highlight\"}}},{\"node\":{\"excerpt\":\"Java中的类加载时机 遇到      或者  这四种字节码指令时，对类进行初始化\\n 可以认定为一种特殊的静态方法 使用反射方法对类进行反射调用的时候 当初始化一个类的时候，自动初始化其父类 当虚拟机启动时，会触发执行主类（包含main方法的那个类）的初始化 使用JDK...\",\"frontmatter\":{\"path\":\"/java-classloader/\",\"date\":\"05 September, 2017\",\"title\":\"Java Classloader\"}}},{\"node\":{\"excerpt\":\"页面内的快速跳转 标题    分割线    强调    列表    链接    图片    表格    脚注    引用    行内HTML    分割线 标题 H1 H2 H3 H4 H5 H6 Alt-H1 Alt-H...\",\"frontmatter\":{\"path\":\"/markdown-learning\",\"date\":\"05 September, 2017\",\"title\":\"Markdown Learning\"}}},{\"node\":{\"excerpt\":\"Far far away, behind the word mountains, far from the countries Vokalia\\nand Consonantia, there live the blind texts. Separated they live in...\",\"frontmatter\":{\"path\":\"/hi-folks/\",\"date\":\"28 May, 2015\",\"title\":\"New Beginnings\"}}}]}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/index.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/index.json\n// module chunks = 9347362237655822000"],"sourceRoot":""}