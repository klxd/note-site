{"version":3,"sources":["webpack:///path---encoding-2894019b5d3860e751f8.js","webpack:///./.cache/json/encoding.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/encoding.json","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","tags","pathContext","path"],"mappings":"AAAAA,cAAc,qBAERC,kEACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,YAAAC,OAAA,UAAsCC,gBAAmBC,GAAA,oHAAAC,KAAA,khEAAAC,aAAuqEL,MAAA,WAAAM,KAAA,qBAAAC,MAAA,sBAA4EC,aAAgBC,KAAA","file":"path---encoding-2894019b5d3860e751f8.js","sourcesContent":["webpackJsonp([6651855161709604000],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/encoding.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Note Site\",\"author\":\"stone\"}},\"markdownRemark\":{\"id\":\"/home/peng/develop/workspace/stone-site/src/pages/2017-09-12-encoding/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>ASCII</h2>\\n<p>American Standard Code for Information Interchange，美国信息互换标准代码）\\n最常见的英文编码，标准的ASCII码表是128个字符,\\n范围是0x00~0x7F (0000 0000 ~ 0111 1111),\\n扩展的ASCII字符把最高位也用上了,即共有256个字符。</p>\\n<h2>ISO 8859-1:1998</h2>\\n<p>又称<code>Latin-1</code>或<code>西欧语言</code>\\n以ASCII为基础</p>\\n<h2>UCS</h2>\\n<p>由ISO（国际标谁化组织）提出,全名Universal Coded Character Set，简称<code>UCS</code>。</p>\\n<h2>Unicode</h2>\\n<p>也叫<code>unicode</code>.\\nUnicode是计算机科学领域里的一项业界标准,包括字符集、编码方案等。\\nUnicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中\\n的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行\\n文本转换、处理的要求。<a href=\\\"http://www.unicode.org/standard/standard.html\\\">Unicode Standard</a>\\n中详叙了相关信息。\\n原始的unicode编码有以下问题</p>\\n<blockquote>\\n<ol>\\n<li><strong>无法兼容ASCII</strong>如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？</li>\\n<li><strong>浪费存储空间</strong>英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，\\n那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的</li>\\n</ol>\\n</blockquote>\\n<h2>UTF-8</h2>\\n<p>unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）\\n标准出现了，顾名思义，UTF-8就是每次8个位传输数据。\\nUTF-8就是在互联网上使用最广的一种unicode的实现方式，收录于<a href=\\\"https://www.ietf.org/rfc/rfc2279.txt\\\">RFC 2279</a>\\n中。UTF-8是一种变长编码，对于不同的字符范围使用不同长度的编码。如下表</p>\\n<table>\\n<thead>\\n<tr>\\n<th>UCS-4 range (hex.)</th>\\n<th>UTF-8 octet sequence (binary)</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>0000 0000-0000 007F</td>\\n<td>0xxxxxxx</td>\\n</tr>\\n<tr>\\n<td>0000 0080-0000 07FF</td>\\n<td>110xxxxx 10xxxxxx</td>\\n</tr>\\n<tr>\\n<td>0000 0800-0000 FFFF</td>\\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\\n</tr>\\n<tr>\\n<td>0001 0000-001F FFFF</td>\\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\\n</tr>\\n<tr>\\n<td>0400 0000-7FFF FFFF</td>\\n<td>1111110x 10xxxxxx … 10xxxxxx</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>UTF-16</h2>\\n<h3>UTF-16-LE</h3>\\n<h3>UTF-16-BE</h3>\\n<p>BOM</p>\\n<p>Byte Order Mark\\nUnicode编码中特有的一个概念, 表明了文件编码是<code>大端字节序</code>还是<code>小端字节序</code>\\n<code>FEFF</code> big endian\\n<code>FFFE</code> little endian</p>\\n<p>在utf-8编码中,BOM只是用于标记这个文件是utf-8格式,并没有声明字节序的作用</p>\\n<p><a href=\\\"http://lukejin.iteye.com/blog/586088\\\">java charset blog</a></p>\",\"frontmatter\":{\"title\":\"Encoding\",\"date\":\"September 12, 2017\",\"tags\":[\"encoding\",\"java\"]}}},\"pathContext\":{\"path\":\"/encoding\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---encoding-2894019b5d3860e751f8.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Note Site\",\"author\":\"stone\"}},\"markdownRemark\":{\"id\":\"/home/peng/develop/workspace/stone-site/src/pages/2017-09-12-encoding/index.md absPath of file >>> MarkdownRemark\",\"html\":\"<h2>ASCII</h2>\\n<p>American Standard Code for Information Interchange，美国信息互换标准代码）\\n最常见的英文编码，标准的ASCII码表是128个字符,\\n范围是0x00~0x7F (0000 0000 ~ 0111 1111),\\n扩展的ASCII字符把最高位也用上了,即共有256个字符。</p>\\n<h2>ISO 8859-1:1998</h2>\\n<p>又称<code>Latin-1</code>或<code>西欧语言</code>\\n以ASCII为基础</p>\\n<h2>UCS</h2>\\n<p>由ISO（国际标谁化组织）提出,全名Universal Coded Character Set，简称<code>UCS</code>。</p>\\n<h2>Unicode</h2>\\n<p>也叫<code>unicode</code>.\\nUnicode是计算机科学领域里的一项业界标准,包括字符集、编码方案等。\\nUnicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中\\n的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行\\n文本转换、处理的要求。<a href=\\\"http://www.unicode.org/standard/standard.html\\\">Unicode Standard</a>\\n中详叙了相关信息。\\n原始的unicode编码有以下问题</p>\\n<blockquote>\\n<ol>\\n<li><strong>无法兼容ASCII</strong>如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？</li>\\n<li><strong>浪费存储空间</strong>英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，\\n那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的</li>\\n</ol>\\n</blockquote>\\n<h2>UTF-8</h2>\\n<p>unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）\\n标准出现了，顾名思义，UTF-8就是每次8个位传输数据。\\nUTF-8就是在互联网上使用最广的一种unicode的实现方式，收录于<a href=\\\"https://www.ietf.org/rfc/rfc2279.txt\\\">RFC 2279</a>\\n中。UTF-8是一种变长编码，对于不同的字符范围使用不同长度的编码。如下表</p>\\n<table>\\n<thead>\\n<tr>\\n<th>UCS-4 range (hex.)</th>\\n<th>UTF-8 octet sequence (binary)</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>0000 0000-0000 007F</td>\\n<td>0xxxxxxx</td>\\n</tr>\\n<tr>\\n<td>0000 0080-0000 07FF</td>\\n<td>110xxxxx 10xxxxxx</td>\\n</tr>\\n<tr>\\n<td>0000 0800-0000 FFFF</td>\\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\\n</tr>\\n<tr>\\n<td>0001 0000-001F FFFF</td>\\n<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\\n</tr>\\n<tr>\\n<td>0400 0000-7FFF FFFF</td>\\n<td>1111110x 10xxxxxx … 10xxxxxx</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2>UTF-16</h2>\\n<h3>UTF-16-LE</h3>\\n<h3>UTF-16-BE</h3>\\n<p>BOM</p>\\n<p>Byte Order Mark\\nUnicode编码中特有的一个概念, 表明了文件编码是<code>大端字节序</code>还是<code>小端字节序</code>\\n<code>FEFF</code> big endian\\n<code>FFFE</code> little endian</p>\\n<p>在utf-8编码中,BOM只是用于标记这个文件是utf-8格式,并没有声明字节序的作用</p>\\n<p><a href=\\\"http://lukejin.iteye.com/blog/586088\\\">java charset blog</a></p>\",\"frontmatter\":{\"title\":\"Encoding\",\"date\":\"September 12, 2017\",\"tags\":[\"encoding\",\"java\"]}}},\"pathContext\":{\"path\":\"/encoding\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/encoding.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/encoding.json\n// module chunks = 6651855161709604000"],"sourceRoot":""}