---
title: 剑指offer
date: "2016-01-12T22:40:32.169Z"
path: "/sword-to-offer/"
tags:
    - leetcode
---

## LinkedList
### 从尾到头打印链表
### 15 链表中倒数第k个结点
思路: 快慢指针, 快指针先走k-1步, 注意判断链表长度小于k的情况

### 16 反转链表

### 17 合并两个或k个有序链表
    
### 复杂链表的复制

### 036-两个链表的第一个公共结点
解法一： 分别求链表长度，长的链表指针先行`len1-len2`步，然后两个指针一起走，若相等则是第一个相遇点

解法二： 分别遍历 `list1 + null + list2`和`list2 + null + list1`, 注意必须走过null节点，防止两个链表不相交而进入死循环
```java
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode l1 = pHead1, l2 = pHead2;
        while (l1 != l2) {
            l1 = l1 == null ? pHead2 : l1.next;
            l2 = l2 == null ? pHead1 : l2.next;
        }
        return l1;
    }
}
```
### 055-链表中环的入口结点

### 删除链表中重复的结点

### 13 O(1)时间删除链表节点
思路: 将下一个节点数据复制到当前节点, 删除下一个节点.
注意当节点为最后一个节点, 仍需要遍历链表, 时间复杂度退化.
注意删除节点是头节点的情况.

Tree
### 重建二叉树    
### 18 树的子结构
思路: 主函数-是否有子结构, 辅助函数-是否是一棵超树 

### 19 二叉树的镜像
交换左右子树

### 23 从上往下打印二叉树
简单层次遍历

### 24 二叉搜索树的后序遍历序列
后序遍历最后一个元素为根节点, 将前面的数字根据是否比根节点大分为两部分, 再递归判断
    
### 25 二叉树中和为某一值的路径
遍历时带上当前路径和

### 27 二叉搜索树与双向链表
原理: 数的中序遍历 
解法一: 辅助函数返回链表的头和尾
```java
public class Solution {
    public TreeNode Convert(TreeNode root) {
        if (root == null) {
            return null;
        }
        return solve(root)[0];
    }
    
    private TreeNode[] solve(TreeNode root) {
        TreeNode[] ret = {root, root};
        
        if (root.left != null) {
            TreeNode[] left = solve(root.left);
            ret[0] = left[0];
            left[1].right = root;
            root.left = left[1];
        }
        if (root.right != null) {
            TreeNode[] right = solve(root.right);
            ret[1].right = right[0];
            right[0].left = ret[1];
            ret[1] = right[1];
        }
        return ret;
    }
}
```
    
038-二叉树的深度    
039-平衡二叉树    
057-二叉树的下一个结点    
058-对称的二叉树    
059-按之字形顺序打印二叉树    
060-把二叉树打印成多行    
061-序列化二叉树
062-二叉搜索树的第k个结点

## Stack & Queue
005-用两个栈实现队列
### 21 包含min函数的栈
思路: 入栈:判断元素是否小于等于min栈顶, 满足则也入min栈;
出栈:判断元素是否等于min栈顶, 满足则min栈顶也出栈

### 22 栈的压入、弹出序列
思路: 模拟法, 若当前元素不为出栈序列则入栈, 若压入序列已用完且栈顶不为弹出序列的下一个, 则失败

044-翻转单词顺序列(栈)
064-滑动窗口的最大值(双端队列)

Heap

### 30 最小的K个数
思路一: 基于partition函数的思路, 时间O(1), 需要修改原数组, 不适用于数据流
思路二: 最小堆, 时间O(NlogK), 适用于数据流

## Hash Table

### 50 第一个只出现一次的字符
解法一：使用hashMap或者int数组存储对应字符出现的次数，第一次遍历字符串得每个字符出现的次数，
第二次再遍历字符串，找出现字符次数为1的第一个字符， 时间复杂度 O(n+n).

解法二：使用hashMap或int数组存储对应字符出现的下标，若不存在则存-1，出现超过一次则存储-2，
这样第二次遍历可用O(256)=O(1)的时间得到最小的下标


### 50 变形题：在字符流中找到第一个只出现一次的字符
解法一：同原题解法二， 每次获取字符时， 遍历hashMap或int数组，
读取字符流时间复杂度O(1)，查找第一个出现一次的字符时间复杂度O(256)

解法二：用hashMap或int数组存每个字符出现的次数，使用一个队列，读取字符流时，若此字符是第一个出现，则将其入队，
并循环判断队列头字符出现的次数，如果大于一次，则将其出队。 由于每种字符最多入队一次，队列最大长度等于hashMap大小，空间复杂度不变。
此算法可将查找复杂度优化为O(1)

图
## 065-矩阵中的路径(BFS)
## 066-机器人的运动范围(DFS)

## 具体算法类题目

007-斐波拉契数列    
008-跳台阶    
009-变态跳台阶   
010-矩形覆盖搜索算法
001-二维数组查找
006-旋转数组的最小数字（二分查找）
037-数字在排序数组中出现的次数（二分查找）

### 28 字符串的排列


## 动态规划
### 31 连续子数组的最大和
思路: 前缀和小于0则抛弃

052-正则表达式匹配

## 回溯

065-矩阵中的路径(BFS)
066-机器人的运动范围(DFS)

## 排序

### 51 035-数组中的逆序对(归并排序)    
029-最小的K个数(堆排序)    
029-最小的K个数(快速排序)

 
### 11 数值的整数次方
`double power(double base, int exponent)`
1. 注意判断base和exponent都是0的情况(double值比较)
2. 注意exponent为负数的情况
3. 计算多次幂时, 可用递归或者循环减少计算次数 

040-数组中只出现一次的数字

## 其他算法
002-替换空格
### 14 013-调整数组顺序使奇数位于偶数前面
思路: 类似快排中的partition函数, 两个指针分别指向偶数和奇数, 直到相遇
 
028-数组中出现次数超过一半的数字


031-整数中1出现的次数（从1到n整数中1出现的次数）    
### 33 把数组排成最小的数
思路: 数字排序, 比较函数: 分别合并两个字符串为一个数字, 小的排前面


### 34 丑数
题意: 因子中只有2,3,5的数字为丑数, 求第N个丑数
思路: 按序生产丑数, 每个新丑数都是都前面的丑数乘以2,3,5得到的,维护三个指针,
每次从这三个指针对应的丑数中生成新的丑数, 选最小的一个, 移动指针该指针(可能同时多个) 

041-和为S的连续正数序列(滑动窗口思想)    
042-和为S的两个数字(双指针思想)    
043-左旋转字符串(矩阵翻转)
046-孩子们的游戏-圆圈中最后剩下的数(约瑟夫环)   
051-构建乘积数组

###　011-二进制中1的个数

### 20 顺时针打印矩阵