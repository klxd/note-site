---
title: 网络协议
date: "2018-02-011T22:22:22.169Z"
path:  "/net-protocol"
tags:
   - web
---

## 网络七层模型
OSI 模型(Open System Interconnection model)是一个由国际标准化组织􏰁提出的概念模型,
试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。
它将计算机网络体系结构划分为七层,每层都可以􏰁供抽象良好的接口。
了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。

### 物理层 
负责最后将信息编码成电流脉冲(0和1)或其它信号用于网上传输

### 数据链路层
提供介质访问和链路管理, 不同的数据链路层定义了不同的网络和协 议特征,
其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控;

可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式；

### 网络层
IP选址和路由选择

可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6！
常见协议, IP，ICMP，OSPF，EIGRP，IGMP

### 传输层
建立,管理和维护端(port)到端的连接, TCP/UDP

可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！

### 会话层
建立,管理和维护会话

### 表示层
数据格式转化,数据加密

### 应用层
为应用程序提供服务 HTTP, FTP, Telnet等

## TCP三次握手
* SYN：用作建立连接时的同步信号
* ACK：用于对收到的数据进行确认，所确认的数据由确认序列号表示。
* FIN：表示后面没有数据需要发送，通常意昧着所建立的连接需要关闭了

1. A请求连接, SYN=1, seq=x (其中x为ISN)
2. B回复 SYN=1, ACK=1, seq=y, ack=x+1 (SYN和ACK合并发送)
3. A回复, ACK=1, seq=x+1, ack=y+1

三次握手之后才能够保证两台服务器都完全没有问题，各自具备发报和收报能力

### ISN(Initial Sequence Number)
当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。
ISN可以看作是一个32比特的计数器，每4ms加1。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

### 三次握手过程携带数据
第三次握手的时候，是可以携带数据的, 此时客户端已经处于 ESTABLISHED 状态。但是，第一次、第二次握手不可以携带数据
假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。
因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

### SYN 攻击(SYN Flood)
在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。
此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。
由于源地址是不存在的，服务器需要不断的重发直至超时，(或重传次数超过系统规定的最大重传次数, 每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s)
这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

SYN 攻击是一种典型的 DoS/DDoS 攻击。

* 检测: 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

* 防御, SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御SYN攻击的方法有如下几种：
  * 缩短超时（SYN Timeout）时间
  * 增加最大半连接数
  * 过滤网关防护
  * SYN cookies技术


## TCP4次挥手
1. A, FIN, seq=p (表示A没有报文要发送了, 准备关闭连接)
2. B, ACK, ack=p+1, (A收到此报文后进入FIN_WAIT状态, 继续等待B的报文)
3. B, FIN, ACK, seq=q, ack=p+1 (表示B没有报文要发送了, 发起关闭连接)
4. A, ACK, ack=q+1 (A发送后进入TIME_WAIT状态,等待2MSL后关闭连接, B则在收到A的ACK后马上关闭连接)

### 2MSL等待状态
TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），
它是任何报文段被丢弃前在网络内的最长时间, 超过这个时间报文将被丢弃。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。
这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。
这个连接只能在2MSL结束后才能再被使用。

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。
服务器会**超时重传**这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。
假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

两个理由：
* 保证客户端发送的最后一个ACK报文段能够到达服务端。
  这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，
  而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，
  若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，
  则服务端无法正常进入到CLOSED状态。
* 防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，
  使下一个新的连接中不会出现这种旧的连接请求报文段。

Q: 为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。
只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送, 故需要四步握手。

## TCP中的四种定时器

## Q & A
* http请求的整个过程
* https的处理过程,https什么时候使用对称加密
* https和http区别，有没有用过其他安全传输手段
* HTTP 301 302有啥区别


## 参考
* [阮一峰:互联网协议入门](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)