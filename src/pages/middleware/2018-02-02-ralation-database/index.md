---
title: 数据库学习笔记
date: "2018-02-02T22:22:22.169Z"
path:  "/relation-database"
tags:
   - middleware
---

## 数据库事务
四大特性 - ACID
* 原子性 (Atomicity)
* 一致性 (Consistency)
* 隔离性 (Isolation)
* 持久性 (Durability)


## 事务隔离级别

### 为什么要有隔离级别

如果事务之间没有隔离性, 可能会发生以下问题
* `脏读`(Dirty Read): 一个事务在处理过程中读取了另一个**未提交事务**中的数据
* `不可重复读`(Non-Repeatable Read): 一个事务范围内,多次查询同一个数据, 却返回了
  不同的数据值. 发生的原因是在查询的间隔, 数据被另一个事务修改并且提交了
* `幻读`(Phantom Read): 幻读是事务非独立执行时发生的一种现象, 例如事务T1对一个表
  中所有的行的某个数据项做了从“1”修改为“2”的操作, 这时事务T2又对这个表中插入了一行数据项,
  而这个数据项的数值还是为“1”并且提交给数据库. 而操作事务T1的用户如果再查看刚刚修改的数据,
   会发现还有一行没有修改，其实这行是从事务T2中添加的, 就好像产生幻觉一样, 这就是发生了幻读。
   幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）

### 四种事务隔离级别
在 SQL 标准中定义了四种数据库的事务的隔离级别：每个事务的隔离级别其实都比上一级多解 
* `RAED UNCOMMITED`：使用查询语句不会加锁，可能会读到未提交的行(Dirty Read)
* `READ COMMITED`：只对记录加记录锁，而不会在记录之间加间隙锁，
   所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，
   可能得到不同的结果(Non-Repeatable Read)
* `REPEATABLE READ`：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同
   的数据行，但是可能发生幻读(Phantom Read)
* `SERIALIZABLE`：InnoDB(数据库引擎之一)隐式地将全部的查询语句加上共享锁，解决了幻读的问题

以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，
执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)
使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。
在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。
oracle默认隔离级别 Read committed

### 设置隔离级别
设置数据库的隔离级别一定要是在开启事务之前, 如果是使用JDBC对数据库的事务设置隔离级别的话，
也应该是在调用Connection对象的setAutoCommit(false)方法之前。

隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，
当前窗口设置的隔离级别只对当前窗口中的事务有效; 
对于JDBC操作数据库来说，一个Connection对象相当于一个链接，
而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。

### 隔离级别的实现
#### 锁
锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，
而是只会锁住那些需要访问的数据项， 
MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），
前者也叫读锁，后者叫写锁。 读锁保证了读操作可以并发执行，相互不会影响，
而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。

#### 时间戳

除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，
例如 PostgreSQL 会为每一条记录保留两个字段；
读时间戳中报错了所有访问该记录的事务中的最大时间戳，
而记录行的写时间戳中保存了将记录改到当前值的事务的时间戳。


#### 多版本和快照隔离

通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取，
很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，
所以能够显著地提升读的性能，MySQL 和 PostgreSQL 都对这一机制进行自己的实现，
也就是 MVCC，虽然各自实现的方式有所不同，MySQL 就通过文章中提到的回滚日志实现了 MVCC，
保证事务并行执行时能够不等待互斥锁的释放直接获取数据

## mysql事务能保证失败回滚

想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚
，而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，
所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。

回滚日志除了能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息，
它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，
还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，
这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要**先写日志后写数据库**的主要原因。

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；
它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库
中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 
都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。

## mysql数据库的锁有多少种，怎么编写加锁的sql语句
## mysql什么情况下会触发表锁
## 页锁、乐观锁、悲观锁

## B+树

## 参考
[浅入深出MySQL中事务的实现](https://draveness.me/mysql-transaction)