---
title: 数据库学习笔记
date: "2018-02-02T22:22:22.169Z"
path:  "/relation-database"
tags:
   - middleware
---

## 数据库事务
四大特性 - ACID
* 原子性 (Atomicity)
* 一致性 (Consistency)
* 隔离性 (Isolation)
* 持久性 (Durability)


## 事务隔离级别

### 为什么要有隔离级别

如果事务之间没有隔离性, 可能会发生以下问题
* `脏读`(Dirty Read): 一个事务在处理过程中读取了另一个**未提交事务**中的数据
* `不可重复读`(Non-Repeatable Read): 一个事务范围内,多次查询同一个数据, 却返回了
  不同的数据值. 发生的原因是在查询的间隔, 数据被另一个事务修改并且提交了
* `幻读`(Phantom Read): 幻读是事务非独立执行时发生的一种现象, 例如事务T1对一个表
  中所有的行的某个数据项做了从“1”修改为“2”的操作, 这时事务T2又对这个表中插入了一行数据项,
  而这个数据项的数值还是为“1”并且提交给数据库. 而操作事务T1的用户如果再查看刚刚修改的数据,
   会发现还有一行没有修改，其实这行是从事务T2中添加的, 就好像产生幻觉一样, 这就是发生了幻读。
   幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，
   而幻读针对的是一批数据整体（比如数据的个数）

### 四种事务隔离级别
在 SQL 标准中定义了四种数据库的事务的隔离级别：每个事务的隔离级别其实都比上一级多解 
* `RAED UNCOMMITED`：使用查询语句不会加锁，可能会读到未提交的行(Dirty Read)
* `READ COMMITED`：只对记录加记录锁，而不会在记录之间加间隙锁，
   所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，
   可能得到不同的结果(Non-Repeatable Read)
* `REPEATABLE READ`：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同
   的数据行，但是可能发生幻读(Phantom Read)
* `SERIALIZABLE`：InnoDB(数据库引擎之一)隐式地将全部的查询语句加上共享锁，解决了幻读的问题

以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，
执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)
使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。
在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。
oracle默认隔离级别 Read committed

### 设置隔离级别
设置数据库的隔离级别一定要是在开启事务之前, 如果是使用JDBC对数据库的事务设置隔离级别的话，
也应该是在调用Connection对象的setAutoCommit(false)方法之前。

隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，
当前窗口设置的隔离级别只对当前窗口中的事务有效; 
对于JDBC操作数据库来说，一个Connection对象相当于一个链接，
而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。

### 隔离级别的实现
#### 锁
锁是一种最为常见的并发控制机制，在一个事务中，我们并不会将整个数据库都加锁，
而是只会锁住那些需要访问的数据项， 
MySQL 和常见数据库中的锁都分为两种，共享锁（Shared）和互斥锁（Exclusive），
前者也叫读锁，后者叫写锁。 读锁保证了读操作可以并发执行，相互不会影响，
而写锁保证了在更新数据库数据时不会有其他的事务访问或者更改同一条记录造成不可预知的问题。

#### 时间戳

除了锁，另一种实现事务的隔离性的方式就是通过时间戳，使用这种方式实现事务的数据库，
例如 PostgreSQL 会为每一条记录保留两个字段；
* 读时间戳中保存了所有访问该记录的事务中的最大时间戳，
* 而记录行的写时间戳中保存了将记录改到当前值的事务的时间戳。


#### 多版本和快照隔离

通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取，
很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，
所以能够显著地提升读的性能，MySQL 和 PostgreSQL 都对这一机制进行自己的实现，
也就是 MVCC，虽然各自实现的方式有所不同，MySQL 就通过文章中提到的回滚日志实现了 MVCC，
保证事务并行执行时能够不等待互斥锁的释放直接获取数据

## mysql事务能保证失败回滚

想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚
，而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，
所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。

回滚日志除了能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息，
它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，
还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，
这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要**先写日志后写数据库**的主要原因。

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；
它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库
中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 
都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。

## mysql数据库的锁有多少种，怎么编写加锁的sql语句

* **行级锁** 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。
   行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为两种:
   1. 共享锁 (读锁)
      * 用法: SELECT ... LOCK IN SHARE MODE;
   2. 排它锁 (写锁)
      * 用法: SELECT ... FOR UPDATE;

* **表级锁**  表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，
   它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。
   意向锁:  意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。
   意向锁是InnoDB自动加的，不需用户干预, InnoDB中的两个表锁：
   
    1. 意向共享锁（IS）：表示**事务**准备给数据行加入共享锁，
       也就是说一个数据行加共享锁前必须先取得该表的IS锁
   
    2. 意向排他锁（IX）：类似上面，表示**事务**准备给数据行加入排他锁，
       说明事务在一个数据行加排他锁前必须先取得该表的IX锁。

* **页级锁**  页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。
   表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，
   一次锁定相邻的一组记录。BDB支持页级锁
   
      


## mysql什么情况下会触发表锁
## 页锁、乐观锁、悲观锁

## 数据库的索引数据结构

### B树

二叉搜索树：
1. 每个非叶节点最多有一个儿子
2. 每个节点都只存一个关键字
3. 节点左子树小于其关键字，右子树大于其关键字

若节点的左右子树深度相差太大，可能退化为链表。
平衡算法： AVL树



### B-树
多路搜索树，并不是二叉的，对于一颗M阶的B-树：
1. 任意非叶子节点最多只有M个儿子，且M>2
2. 根节点的儿子数目为`[2, M]`
3. 除根节点外的非叶子节点儿子数为`[M/2, M]`

B-树的特性：
   1. 关键字集合分布在整颗树中；
   2.任何一个关键字出现且只出现在一个结点中；
   3.搜索有可能在非叶子结点结束；
   4.其搜索性能等价于在关键字全集内做一次二分查找(logN)；
   5.自动层次控制；

### B+树

B+ 树是 B 树的一种变体，也是一种多路平衡查找树， 它和 B 树主要不同点在：

* 每个节点最多含有 m 个关键字
* 所有的叶节点中包含了全部关键字的信息，以及指向还有这些关节字记录的指针
* 叶节点本身按照关键字顺序相互连接
* 所有非叶节点可以看成是索引部门，节点中仅包含其子树中最大关键字。

由于以上不同点，B+树有如下特性：
1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
2.不可能在非叶子结点命中；
3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
4.更适合文件索引系统

为什么不用 B树 或者 B-树
一般来说， MySQL 中的 B-Tree 索引的物理文件大多都是以 Balance Tree 的结构来存储的，
也就是所有实际需要的数据都存放于 Tree 的 Leaf Node(叶子节点) ，
而且到任何一个 Leaf Node 的最短路径的长度都是完全相同的，
所以我们大家都称之为 B-Tree 索引。当然，可能各种数据库（或 MySQL 的各种存储引擎）在存放自己的
 B-Tree 索引的时候会对存储结构稍作改造。
 如 Innodb 存储引擎的 B-Tree 索引实际使用的存储结构实际上是 B+Tree，
 也就是在 B-Tree 数据结构的基础上做了很小的改造，
 在每一个Leaf Node 上面出了存放索引键的相关信息之外，
 还存储了指向与该 Leaf Node 相邻的后一个 LeafNode 的指针信息（增加了顺序访问指针），
 这主要是为了加快检索多个相邻 Leaf Node 的效率考虑。


## 多字段索引时, 索引能正确使用么

## InnoDB表最好要用自增列做主键
* 如果我们定义了主键(PRIMARY KEY), 那么InnoDB会选择主键作为聚集索引、如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。

* 数据记录本身被存于主索引（一颗B+Tree）的叶子节点上, 这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）

* 如果表使用自增主键, 那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

* 如果使用非自增主键（如果身份证号或学号等）, 由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

总结：如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的，
也就是下面这几种情况的存取效率最高：
1. 使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致；

2. 该表不指定自增列做主键，同时也没有可以被选为主键的唯一索引(上面的条件)，这时候InnoDB会选择内置的ROWID作为主键，写入顺序和ROWID增长顺序一致；

3. 如果一个InnoDB表又没有显示主键，又有可以被选择为主键的唯一索引，但该唯一索引可能不


## 数据库的锁机制

## 数据库的优化 最好不要设置null值 避免sql语句中进行计算 避免in ，导致全表扫描

## 对MySQL的了解，和oracle的区别




## 参考
* [浅入深出MySQL中事务的实现](https://draveness.me/mysql-transaction)
* [MySQL索引背后的数据结构及算法原理](https://www.kancloud.cn/kancloud/theory-of-mysql-index/41856)
* [B树，B-树，B+树，B*树，位图索引，Hash索引](http://blog.csdn.net/wl044090432/article/details/53423333)