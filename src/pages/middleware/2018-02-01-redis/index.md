---
title: Redis学习笔记
date: "2018-02-01T22:22:22.169Z"
path:  "/redis-note"
tags:
   - middleware
---

## Redis中的五种基本数据类型

* string 字符串是redis最基本的类型
* hash string类型键值(key=>value)对集合,hash特别适合用于存储对象
* list 简单的字符串列表，按照插入顺序排序
* set string类型的无序集合 通过hash和skiplist实现的
* zset(sort set) 每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序

## 事务——Transactions
虽然 Redis 的 Transactions 提供的并不是严格的 ACID 的事务
（比如一串用 EXEC 提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行）,
但是这个 Transactions 还是提供了基本的命令打包执行的功能
（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间不会有其它客户端命令插进来执行）.
Redis 还提供了一个 Watch 功能，你可以对一个 key 进行 Watch，然后再执行 Transactions，
在这过程中，如果这个 Watched 的值进行了修改，那么这个 Transactions 会发现并拒绝执行。

## 键分布模型
* Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。
* 推荐的最大节点数量为 1000 个左右。每个主节点都负责处理 16384 个哈希槽的其中一部分。
* 当我们说一个集群处于“稳定”（stable）状态时， 指的是集群没有在执行重配（reconfiguration）操作，
  每个哈希槽都只由一个节点进行处理。重配置指的是将某个/某些槽从一个节点移动到另一个节点。
  一个主节点可以有任意多个从节点，这些从节点用于在主节点发生网络断线或者节点失效时， 对主节点进行替换。


## Redis 数据迁移 (主节点增加)
MIGRATE target_host target_port key target_database id timeout
* 该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B , 
  （在移动键期间，两个节点都会处于**阻塞**状态，以免出现竞争条件）

* 执行MIGRATE 命令的节点会连接到 target 节点， 
  并将序列化后的 key 数据发送给 target ， 一旦 target 返回 OK ,
  节点就将自己的 key 从数据库中删除。

* 从一个外部客户端的视角来看， 在某个时间点上， 键 key 要么存在于节点 A ， 
要么存在于节点 B ， 但不会同时存在于节点 A 和节点 B 。

* 因为 Redis集群只使用 0 号数据库， 所以当 MIGRATE 命令被用于执行集群操作时， 
  target_database 的值总是 0 。

## Redis主从复制
在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求。
Redis也是如此，它为我们提供了复制功能，实现了相同数据的多个Redis副本。复制功能是高可用Redis的基础

* 参与复制的Redis实例划分为主节点（master）和从节点（slave）。默认情况下，Redis都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。
  复制的数据流是单向的，只能由主节点复制到从节点。
* 默认情况下，从节点使用slave-read-only=yes配置为只读模式。由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，
  修改从节点会造成主从数据不一致。因此建议线上不要修改从节点的只读模式。

## 主从节点模式下如何保持一致性
从Redis 2.8版本开始，可以配置主服务器连接N个以上从服务器才允许对主服务器进行写操作。
但是，因为Redis使用的是异步主从复制，没办法确保从服务器确实收到了要写入的数据，
所以还是有一定的数据丢失的可能性。

这一特性的工作原理如下：
* 从服务器每秒钟ping一次主服务器，确认处理的复制流数量。
* 主服务器记住每个从服务器最近一次ping的时间。
* 用户可以配置最少要有N个服务器有小于M秒的确认延迟。

如果有N个以上从服务器，并且确认延迟小于M秒，主服务器接受写操作。

你可以把这看做是CAP原则（一致性，可用性，分区容错性）不严格的**一致性**实现，
虽然不能百分百确保一致性，但至少保证了丢失的数据不会超过M秒内的数据量。

如果条件不满足，主服务器会拒绝写操作并返回一个错误。
* min-slaves-to-write（最小从服务器数）
* min-slaves-max-lag（从服务器最大确认延迟）

## 持久化
Redis虽然是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，
为了解决这个问题Redis提供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。

* RDB持久化
   * redis提供了RDB持久化的功能，这个功能可以将redis在内存中的的状态保存到硬盘中，它可以手动执行，也可以再redis.conf中配置，定期执行。
     
   * RDB持久化产生的RDB文件是一个经过压缩的二进制文件，这个文件被保存在硬盘中，
     redis可以通过这个文件还原数据库当时的状态。
     
* AOF持久化
   * AOF持久化是通过保存Redis服务器锁执行的写状态来记录数据库的。

对比:
* AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢， 也更完整。
* RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小，恢复数度较快


## Question
* redis的操作是不是原子操作
   * Redis所有单个命令的执行都是原子性的, 深层原因是Redis底层是单线程的
   * 多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来
   * 可以利用watch, MULTI和EXEC实现CAS

* 如何实现分布式缓存

* 缓存击穿如何处理

* 缓存预热

## 参考
* [Redis 菜鸟教程](http://www.runoob.com/redis/redis-data-types.html)
* [使用Redis实现分布式锁及其优化](http://mzorro.me/2017/10/25/redis-distributed-lock/)
* [Redis主从复制总结整理](http://alinuxer.sinaapp.com/?p=340)
* [Redis 集群规范](http://redisdoc.com/topic/cluster-spec.html)