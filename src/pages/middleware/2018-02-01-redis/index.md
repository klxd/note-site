---
title: Redis学习笔记
date: "2018-02-01T22:22:22.169Z"
path:  "/redis-note"
tags:
   - middleware
---

## Redis中的五种基本数据类型

* string 字符串是redis最基本的类型
* hash string类型键值(key=>value)对集合,hash特别适合用于存储对象
* list 简单的字符串列表，按照插入顺序排序
* set string类型的无序集合 通过hash和skiplist实现的
* zset(sort set) 每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序

## 事务——Transactions
虽然 Redis 的 Transactions 提供的并不是严格的 ACID 的事务
（比如一串用 EXEC 提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行）,
但是这个 Transactions 还是提供了基本的命令打包执行的功能
（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间不会有其它客户端命令插进来执行）.
Redis 还提供了一个 Watch 功能，你可以对一个 key 进行 Watch，然后再执行 Transactions，
在这过程中，如果这个 Watched 的值进行了修改，那么这个 Transactions 会发现并拒绝执行。

## 键分布模型
* Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。
* 推荐的最大节点数量为 1000 个左右。每个主节点都负责处理 16384 个哈希槽的其中一部分。
* 当我们说一个集群处于“稳定”（stable）状态时， 指的是集群没有在执行重配（reconfiguration）操作，
  每个哈希槽都只由一个节点进行处理。重配置指的是将某个/某些槽从一个节点移动到另一个节点。
  一个主节点可以有任意多个从节点，这些从节点用于在主节点发生网络断线或者节点失效时， 对主节点进行替换。


## Redis 数据迁移 (主节点增加)
MIGRATE target_host target_port key target_database id timeout
* 该命令会将所指定的键原子地（atomic）从节点 A 移动到节点 B , 
  （在移动键期间，两个节点都会处于**阻塞**状态，以免出现竞争条件）

* 执行MIGRATE 命令的节点会连接到 target 节点， 
  并将序列化后的 key 数据发送给 target ， 一旦 target 返回 OK ,
  节点就将自己的 key 从数据库中删除。

* 从一个外部客户端的视角来看， 在某个时间点上， 键 key 要么存在于节点 A ， 
要么存在于节点 B ， 但不会同时存在于节点 A 和节点 B 。

* 因为 Redis集群只使用 0 号数据库， 所以当 MIGRATE 命令被用于执行集群操作时， 
  target_database 的值总是 0 。

## Redis主从复制
在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求。
Redis也是如此，它为我们提供了复制功能，实现了相同数据的多个Redis副本。复制功能是高可用Redis的基础

* 参与复制的Redis实例划分为主节点（master）和从节点（slave）。默认情况下，Redis都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。
  复制的数据流是单向的，只能由主节点复制到从节点。
* 默认情况下，从节点使用slave-read-only=yes配置为只读模式。由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，
  修改从节点会造成主从数据不一致。因此建议线上不要修改从节点的只读模式。

## 主从节点模式下如何保持一致性
从Redis 2.8版本开始，可以配置主服务器连接N个以上从服务器才允许对主服务器进行写操作。
但是，因为Redis使用的是异步主从复制，没办法确保从服务器确实收到了要写入的数据，
所以还是有一定的数据丢失的可能性。

这一特性的工作原理如下：
* 从服务器每秒钟ping一次主服务器，确认处理的复制流数量。
* 主服务器记住每个从服务器最近一次ping的时间。
* 用户可以配置最少要有N个服务器有小于M秒的确认延迟。

如果有N个以上从服务器，并且确认延迟小于M秒，主服务器接受写操作。

你可以把这看做是CAP原则（一致性，可用性，分区容错性）不严格的**一致性**实现，
虽然不能百分百确保一致性，但至少保证了丢失的数据不会超过M秒内的数据量。

如果条件不满足，主服务器会拒绝写操作并返回一个错误。
* min-slaves-to-write（最小从服务器数）
* min-slaves-max-lag（从服务器最大确认延迟）

## 持久化
Redis虽然是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，
为了解决这个问题Redis提供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。

* RDB持久化
   * redis提供了RDB持久化的功能，这个功能可以将redis在内存中的的状态保存到硬盘中，它可以手动执行，也可以再redis.conf中配置，定期执行。
   * RDB持久化产生的RDB文件是一个经过压缩的二进制文件，这个文件被保存在硬盘中，redis可以通过这个文件还原数据库当时的状态。
   * 生成 -- 有两个redis命令可以生成RDB文件, SAVE(阻塞服务器进程,RDB文件创建期间无法处理其他请求), BGSAVE(background save, 派生子进程来处理)
   * 载入, 优先使用AOF文件来还原数据, redis启动时只要检测到RDB文件的存在, 且没有AOF文件(AOF持久化功能关闭), 就会自动载入
     
* AOF(Append Only File)持久化
   * AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。
   * 命令请求会先保存到AOF缓冲区(内存)里面, 再定期写入并同步到AOF文件
   * appendfsync选项的不同值对AOF持久化功能的安全性和服务器性能有很大影响
   * AOF重写可以产生一个新的AOF文件, 这个新的文件和原有的文件所保存的数据库状态一样, 但体积更小
   * AOF重写是通过读取数据库中的键值对来实现的,无须对现有的AOF文件进行任何分析操作

对比:
* AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢， 也更完整。
* RDB持久化，安全性较差，它是正常时期数据备份及master-slave数据同步的最佳手段，文件尺寸较小，恢复数度较快


## 缓存穿透

缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，
这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，
可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

**解决方案**

* 布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
* 缓存空结果 如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

## 缓存雪崩

缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线程（进程）写，
从而避免失效时大量的并发请求落到底层存储系统上。

**解决方案**

* 分散过期时间 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

## 缓存击穿

对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。
这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。

缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，
这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

**解决方案**

* 使用互斥锁(mutex key)  业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，
  而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，
  再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。SETNX，是「SET if Not eXists」的缩写，
  也就是只有不存在的时候才设置，可以利用它来实现锁的效果。
* "提前"使用互斥锁(mutex key)：在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。
  当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。伪代码如下：
  


##　Raft算法

* <https://www.cnblogs.com/xybaby/p/10124083.html>
* <https://www.cnblogs.com/mindwind/p/5231986.html>

## 一致性哈希

* <https://blog.csdn.net/u013851082/article/details/68063446>




## Question
* redis的操作是不是原子操作
   * Redis所有单个命令的执行都是原子性的, 深层原因是Redis底层是单线程的
   * 多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来
   * 可以利用watch, MULTI和EXEC实现CAS

* 如何实现分布式缓存

* 缓存击穿如何处理



* 缓存预热

## 参考
* [Redis 菜鸟教程](http://www.runoob.com/redis/redis-data-types.html)
* [使用Redis实现分布式锁及其优化](http://mzorro.me/2017/10/25/redis-distributed-lock/)
* [Redis主从复制总结整理](http://alinuxer.sinaapp.com/?p=340)
* [Redis 集群规范](http://redisdoc.com/topic/cluster-spec.html)

* [Redis系列文章](https://www.cnblogs.com/kismetv/p/9609938.html)