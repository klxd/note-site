webpackJsonp([0x3b81e7ccefc6ba0],{"./node_modules/json-loader/index.js!./.cache/json/java-static-vs-transient.json":function(a,t){a.exports={data:{site:{siteMetadata:{title:"Note Site",author:"stone"}},markdownRemark:{id:"/home/peng/develop/workspace/stone-site/src/pages/2017-12-04-java-static-vs-transient/index.md absPath of file >>> MarkdownRemark",html:'<h2>起因</h2>\n<p>今天工作时遇到一个Java序列化对象中带有static字段的问题,\n一时无法确定Java默认的序列化机制会怎么处理静态域,\nGoogle的时候发现<a href="http://javabeginnerstutorial.com/core-java-tutorial/transient-vs-static-variable-java/">以下文章</a>\n此文将static和transient两个关键字做对比,初看时觉得不错,\n但是仔细看时发现文章得出的结论和我的印象中的Java序列化有大出入,\n于是自己动手写代码验证一下.</p>\n<h2>static域会不会被序列化</h2>\n<p>改文章中的第二部分通过一段代码得出以下<em>结论</em>:</p>\n<blockquote>\n<ol>\n<li>Static variables value can be stored\nwhile serializing if the same is provided while initialization.\n2.If variable is defined as Static and Transient both,\n　than static modifier will govern the behavior of variable and not Transient.</li>\n</ol>\n</blockquote>\n<p>该文作者认为: </p>\n<ol>\n<li>如果序列化时静态域的值等于初始化时候的值，那么静态域就会被序列化</li>\n<li>如果一个域同时拥有static和transient关键字,那么这个域也会被序列化\n其实以上这个两个结论都是不对的</li>\n</ol>\n<p><a href="/99802f98c8606a8a894fde8f16b9c4ba.java">实例代码</a>\n代码运行方法:</p>\n<ol>\n<li>调用serialization方法,生成出employee.dat文件</li>\n<li>修改<code>staticField</code>和<code>staticTransientField</code>的初始值</li>\n<li>调用deserialization方法</li>\n</ol>\n<p>可以看出所有static字段其实并没有被序列化,都会等于<code>代码</code>中的值,\n其实<em>类变量</em>(静态域)的赋值是在类的初始化过程中发生的,\n序列化的是目标是<em>对象</em>而不是类,所以静态变量不会被序列化.</p>\n<h2>如何实现static域的序列化</h2>\n<p>Java默认的serialization机制不会序列化static的域,但是Java允许程序员自定义\n序列化的对象,以下两种方法都可以实现序列化static域(或者transient域)</p>\n<ol>\n<li>重写writeObject()方法和readObject()方法<a href="/14a32ceaf6b1b3b6a3d8de7a1444ed2e.java">代码实例</a></li>\n<li>实现Externalizable接口</li>\n</ol>',frontmatter:{title:"Java中的序列化时的static字段的处理",date:"November 29, 2017",tags:["java","serialization"]}}},pathContext:{path:"/java-static-vs-transient"}}}});
//# sourceMappingURL=path---java-static-vs-transient-5376a2a756c46e9031c1.js.map