webpackJsonp([0x81b8806e42603000],{"./node_modules/json-loader/index.js!./.cache/json/index.json":function(a,e){a.exports={data:{site:{siteMetadata:{title:"Note Site"}},allMarkdownRemark:{edges:[{node:{excerpt:"Future接口简介 Future接口在Java5中被引入,设计初衷是对未来某个时刻发生的结果进行建模. Future只是一个接口,并无法直接用来创建对象 FutureTask类 CompletableFuture类",frontmatter:{title:"Java中的Future接口",path:"/java-future",date:"06 January, 2018",tags:["java"]}}},{node:{excerpt:"原子更新基本类型 AtomicInteger 原子更新整形 AtomicBoolean 原子更新布尔类型 AtomicLong...",frontmatter:{title:"Java中的原子操作类",path:"/java-atomic",date:"25 December, 2017",tags:["java"]}}},{node:{excerpt:"格式化 JS 代码,统一代码风格 分析 JS 代码,提前发现问题,提高代码质量 安装 ESLint 配置 ESLint ESLint 使用支持多种格式的配置文件,可是以 JavaScript,JSON 或 YAML...",frontmatter:{title:"使用ESLint提高代码质量",path:"/eslint-config",date:"25 December, 2017",tags:["javascript","web"]}}},{node:{excerpt:"等待多线程完成的 CountDownLatch CountDownLatch...",frontmatter:{title:"Java中的并发工具类",path:"/java-concurrent-tool",date:"22 December, 2017",tags:["java"]}}},{node:{excerpt:"平台级模块化系统 没有模块化之前 Java 中存在的问题: JDK 过于臃肿 JAR 文件(如 rt.jar)过于臃肿,无法在小的设备或程序中使用 封装不够强大,public 修饰符允许任何人访问 不同版本的类库交叉依赖,无法确定是否共同依赖了相同的 JAR Java SE...",frontmatter:{title:"Java 9 中的新特性",path:"/new-in-java-9",date:"14 December, 2017",tags:["java"]}}},{node:{excerpt:"Microservices 起源 2014 年,James 和 Martin 合作发表了一篇名为 Microservices \n的文章,详细探讨了当时正流行起来的一种服务架构模式—microservice,并出以下定义: In short, the microservice...",frontmatter:{title:"什么是Microservices",path:"/micro-service",date:"13 December, 2017",tags:["architecture"]}}},{node:{excerpt:"Kafka 官方网址 基本概念 Broker Kafka 集群包含一个或多个服务器,这种服务器被称为 broker Topic 每条发布到 Kafka 集群的消息都有一个类别,这个类别被称为 topic Partition 物理上的概念,每个 topic...",frontmatter:{title:"Kafka基础知识",path:"/kafka",date:"30 November, 2017",tags:["middleware","kafka"]}}},{node:{excerpt:"使用 Cassandra 已经有一段时间了,但是平时使用的都是公司内部封装好的接口,对 Cassandra 的特性并不会暴露太多,\n现在在这里总结一下. ACID 原子性(Atomic) 执行一个语句时,事务中的每个更新都必须成功才能称为成功 一致性(Consistent...",frontmatter:{title:"Cassandra基础知识",path:"/cassandra",date:"29 November, 2017",tags:["middleware","database"]}}},{node:{excerpt:"起因 今天工作时遇到一个 Java 序列化对象中带有 static 字段的问题,\n一时无法确定 Java 默认的序列化机制会怎么处理静态域,\nGoogle 的时候发现 以下文章 \n此文将 static 和 transient...",frontmatter:{title:"Java中的序列化时对static字段的处理",path:"/java-static-vs-transient",date:"29 November, 2017",tags:["java","serialization"]}}},{node:{excerpt:"JVM 运行时的数据区域 程序计数器(Program Counter Register) 一块比较小的内存空间,是当前线程所执行的字节码的 行号指示器 为了线程切换后能恢复到正确的执行位置,每个线程都需要有一个独立的程序计数器,即 线程私有 若正在执行的是一个 Java...",frontmatter:{title:"Java Runtime Memory",path:"/java-runtime-memory",date:"24 November, 2017",tags:["java","jvm"]}}},{node:{excerpt:"置顶按钮是大部分网站都会有的一个功能，尤其是阅读型网站（如知乎，微博）。当网页长度过长，用户在浏览到网页底部的时候想返回顶端，此时置顶按钮可以帮助用户快速到达顶端，而不是通过多次滚动滑轮或者是手动调整滚动条。 Github...",frontmatter:{title:"置顶按钮的实现",path:"/back-to-top-button",date:"21 November, 2017",tags:["web","javascript"]}}},{node:{excerpt:"Java Thread Local 线程封闭 当访问共享的可变数据时,通常需要使用同步.一种避免使用同步的方式就是不共享数据,如果仅在单线程内访问数据,\n就不需要同步,这种数据被称为 线程封闭 (Thread Confinement) ThreadLocal...",frontmatter:{title:"Java Thread Local",path:"/java-thread-local",date:"20 November, 2017",tags:["java"]}}},{node:{excerpt:"Java 中的线程池是运用场景最多的并发框架,几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中,合理地使用线程池能够带来...",frontmatter:{title:"Java Thread Pool",path:"/java-thread-pool",date:"19 November, 2017",tags:["java"]}}},{node:{excerpt:"线程基础 Java 中的线程在运行的生命在周期中可能处于以下 6 个状态之一 new 初始状态,线程被构建,但是还没有调用 start()方法 runnable 运行状态,Java 线程将操作系统中的 就绪 和 运行 两种状态都笼统的称作 运行中 blocked...",frontmatter:{title:"Java Thread",path:"/java-thread",date:"17 November, 2017",tags:["java"]}}},{node:{excerpt:"synchronized 对比 Lock lock 获取锁的过程比较可控,粒度更细,synchronize 获得锁的过程由 jvm 控制 synchronize 会自动释放锁,lock 释放锁需要显式调用 synchronized 关键字 Java...",frontmatter:{title:"Java Lock",path:"/java-lock",date:"17 November, 2017",tags:["java"]}}},{node:{excerpt:"Java Serialization 详阅< >18 章 12 节 Java...",frontmatter:{title:"Java Serialization",path:"/java-serialization",date:"16 November, 2017",tags:["java","serialization"]}}},{node:{excerpt:"Java Memory Model 从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）\nJSR-133 提出了 happens-before...",frontmatter:{title:"Java Memory Model",path:"/java-memory-model",date:"14 November, 2017",tags:["java","jvm"]}}},{node:{excerpt:"CopyOnWriteArrayList add E set(int index, E element) remove get",frontmatter:{title:"Java CopyOnWriteArrayList",path:"/java-copy-on-write-array-list",date:"14 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"Node fields size() public V put(K key, V value) transfer 扩容方法 基本思想和 HashMap 很像 支持并发扩容在扩容的时候,总会涉及到一个数组到另一个数组的拷贝操作,基本思路是把这个拷贝操作并发进行. CAS CAS...",frontmatter:{title:"Java ConcurrentHashMap",path:"/java-concurrent-hash-map",date:"13 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"优先队列,能保证每次取出来的元素都是队列中权值最小的(C++中每次取最大的元素) 元素大小比较可使用构造时传入的比较器或者使用元素的自然顺序(natural order) 不允许放入 null 元素 通过完全二叉树实现的最小堆,底层通过数组实现 add() & offer...",frontmatter:{title:"Java PriorityQueue",path:"/java-priority-queue",date:"11 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"实现了 SortedMap 接口,会按照 key 的大小对 map 中的元素进行排序 未实现同步(不是线程安全) key...",frontmatter:{title:"Java TreeMap",path:"/java-tree-map",date:"10 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"Java LinkedHashMap HashMap 的直接子类 在 HashMap 的基础上，采用双向链表将所有的 entry 链接起来 能保证迭代顺序与插入顺序相同 未实现同步（不是线程安全） *",frontmatter:{title:"Java LinkedHashMap",path:"/java-linked-hash-map",date:"08 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"Java Hashtable 抽象父类为 Dictionary (一个过时的类) 实现同步（线程安全） key 和 value 都不允许为空 put() put 方法用 关键字实现同步 判断 value 是否为空,为空则抛出异常 直接计算 key 对象的 hashCode...",frontmatter:{title:"Java Hashtable",path:"/java-hash-table",date:"08 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"SQL Table Join",frontmatter:{title:"SQL Table Join",path:"/sql-table-join",date:"06 November, 2017",tags:["sql"]}}},{node:{excerpt:"Java HashMap Map 的最常用实现 允许放入空元素 (key 允许为空,value 也允许为空) 不保证元素的顺序 未实现同步（不是线程安全） get() hash()函数: 取原对象的 hashCode,左移 1...",frontmatter:{title:"Java HashMap",path:"/java-hash-map",date:"04 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"ArrayDeque 和 LinkedList 是 Deque 的两个通用实现，官方更推荐使用 ArrayDeque 用作栈和队列. 底层通过 循环数组 (circular array)实现 不允许插入 null 元素 没有实现同步(不是线程安全) void addFirst(E...",frontmatter:{title:"Java ArrayDeque",path:"/java-array-deque",date:"04 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"Java LinkedList LinkedList 同时实现了 List 和 Deque 接口 可以当做队列(Queue)或栈(Stack)使用,虽然首选还是 ArrayDeque 没有实现同步 底层通过 双向链表实现 链表节点 Node 链表节点为内部类 Node...",frontmatter:{title:"Java LinkedList",path:"/java-linked-list",date:"03 November, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"ASCII American Standard Code for Information Interchange，美国信息互换标准代码）最常见的英文编码，标准的 ASCII 码表是 128 个字符,\n范围是 0x00~0x7F (0000 0000 ~ 0111 111...",frontmatter:{title:"Encoding",path:"/encoding",date:"12 September, 2017",tags:["encoding","java"]}}},{node:{excerpt:"interface Queue interface 工具类 Arrays 静态工具类,无法实例化 内嵌一个 ArrayList 类, Arrays.asList(T…a) 返回 Arrays 的内部类 ArrayList 的实例 Arrays.ArrayList...",frontmatter:{title:"Java Collection Framework",path:"/java-collection-framework",date:"12 September, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"Java 中最常用的数据结构之一 元素的存放顺序与 的顺序相同 允许放入 元素 未实现同步（不是线程安全） 底层实现是一个 array 数组 add ArrayList 是在 add 之前扩容 允许放入空元素 remove 仅会删除 object...",frontmatter:{title:"Java ArrayList",path:"/java-array-list",date:"12 September, 2017",tags:["java","java collection framework"]}}},{node:{excerpt:"代码区块 标记方法 用三个反引号 ` ` ` 包围 只有声明了程序语言的代码块才会应用语法高亮 缩进 4 个空格或者 1 个制表符 行内代码，用单个反引号 ` 包起来 标记效果 区块会被 和 标签包裹 区块中      会自动转成 html 实体 区块中各种 markdown...",frontmatter:{title:"Code Highlight",path:"/code-highlight",date:"10 September, 2017",tags:["remark","markdown","prismJs"]}}},{node:{excerpt:"Java 中的类加载时机 Java 中类的生命周期包括以下 7 个阶段:\n加载 验证 准备 解析 初始化 使用 卸载 初始化时机 遇到      或者  这四种字节码指令时，对类进行初始化\n 可以认定为一种特殊的静态方法 读取类的被 final...",frontmatter:{title:"Java Classloader",path:"/java-classloader/",date:"05 September, 2017",tags:["java","jvm"]}}},{node:{excerpt:"页面内的快速跳转 标题 分割线 强调 列表 链接 图片 表格 脚注 引用 行内 HTML 分割线 标题 H1 H2 H3 H4 H5 H6 Alt-H1 Alt-H...",frontmatter:{title:"Markdown Learning",path:"/markdown-learning",date:"05 September, 2017",tags:["remark","markdown"]}}},{node:{excerpt:"为什么使用 Gatsby 刚开始想要在 GitHub Pages 上搭建一个博客网站的时候,\n我的需要的只是一个可以帮我将普通文本文件转化为 HTML 的框架,比如已经和 GitHub Pages 深度集成的\n Jekyll...",frontmatter:{title:"使用Gatsby构建静态博客网站",path:"/blog-with-gatsby",date:"03 September, 2017",tags:["web"]}}},{node:{excerpt:"值得参考的 blog https://imququ.com/ http://typecho.org/ https://afoo.me/ http://es6.ruanyifeng.com/ 构建历程 自定义代码高亮样式 增加标签功能 置顶按钮 新增 204...",frontmatter:{title:"关于这个网站",path:"/about-this-site",date:"01 September, 2017",tags:["web"]}}},{node:{excerpt:"1.two sum 给出一个无序数组,从中找出和为某一固定值的两个数字,返回其数组下标 hint 不能直接排序,否则下标关系消失 solution 1: time O(n) space O(n) 新建一个 HashMap,存放 value->index...",frontmatter:{title:"LeetCode 题解",path:"/leetcode/",date:"12 January, 2016",tags:["leetcode"]}}}],group:[{fieldValue:"architecture",totalCount:1},{fieldValue:"database",totalCount:1},{fieldValue:"encoding",totalCount:1},{fieldValue:"java",totalCount:25},{fieldValue:"java collection framework",totalCount:11},{fieldValue:"javascript",totalCount:2},{fieldValue:"jvm",totalCount:3},{fieldValue:"kafka",totalCount:1},{fieldValue:"leetcode",totalCount:1},{fieldValue:"markdown",totalCount:2},{fieldValue:"middleware",totalCount:2},{fieldValue:"prismJs",totalCount:1},{fieldValue:"remark",totalCount:2},{fieldValue:"serialization",totalCount:2},{fieldValue:"sql",totalCount:1},{fieldValue:"web",totalCount:4}]}},pathContext:{}}}});
//# sourceMappingURL=path---index-426fc62233102869ec48.js.map